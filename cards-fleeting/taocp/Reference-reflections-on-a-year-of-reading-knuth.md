# Reflections on a year of reading Knuth

reference: https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art055

## English

Want to feel stupid? Read Knuth! Want to get smarter? Read Knuth! For a long time, I've seen other programmers write in awed, hushed tones about the multi-volume series of books written by Donald Knuth titled "The Art of Computer Programming" (TAOCP). As somebody who genuinely enjoys reading computer programming books — I actually lost track of time reading Richard Steven's "TCP/IP Illustrated" many years ago — when I consistently hear so many positive things about a book or a series of books, it makes it onto my to-read list. I finally got around to picking up a copy of the first three volumes of TAOCP little over a year ago, and I just finished the first volume, having averaged about 30 minutes a day of reading or working problems.


> 想要感到愚蠢嗎？閱讀Knuth！想變得更聰明嗎？閱讀Knuth！很長一段時間以來，我已經看到其他程序員用令人敬畏的，安靜的語調寫了唐納德·克努斯（Donald Knuth）寫的名為“計算機編程的藝術”（TAOCP）的多卷叢書。作為真正熱愛閱讀計算機編程書籍的人-我實際上在很多年前就沒讀過理查德·史蒂文·史蒂文（Richard Steven）的“ TCP / IP Illustrated”（TCP / IP插圖），因為當我不斷聽到關於一本書或一系列書籍的許多積極的看法時，它使它成為我的閱讀清單。終於在一年多以前，我終於找到了TAOCP的前三卷的副本，而我剛讀完第一卷，平均每天閱讀或工作問題約30分鐘。

These books are written college-textbook style: a few pages of exposition followed by some sample exercises to help you solidify the concepts presented. These books include a lot of sample exercises — in some cases, there are more pages of exercises than explanatory material. Almost all of them have answers included in the back of the book if you get stuck.


> 這些書以大學教科書的形式編寫：幾頁說明，然後是一些示例練習，以幫助您鞏固所提出的概念。這些書包括許多示例練習-在某些情況下，練習頁面比解釋性材料還要多。如果您遇到困難，幾乎所有這些答案都將包含在本書的背面。


I worked, or at least attempted to work, every single problem in the first volume. In some cases I settled for just understanding what the question was trying to ask for. In some cases I failed even to accomplish that (don't judge me until you try it yourself). Each problem is assigned a difficulty rating from 0-50 where 0 is trivial and 50 is "unsolved research problem" (in the first edition, Fermat's last theorem was listed as a 50, but since Andrew Wiles proved it, it's bumped down to a 45 in the current edition). I think I was able to solve most of the problems rated < 20 — it was hit and miss beyond that. Most of the problems fell into the 20-30 difficulty range, but Knuth's idea of "difficult" is subjective, and problems that he considers to be of average difficulty ended up stretching my comparatively tiny brain painfully. I've never climbed Mount Everest, but I imagine the whole ordeal feels similar: painful while you're going through it, but triumphant when you reach the pinnacle.



> 在第一卷中，我曾嘗試過或至少嘗試過嘗試解決每一個問題。在某些情況下，我只是為了理解問題的意圖而解決。在某些情況下，我什至沒有做到這一點（在您自己嘗試之前，不要判斷我）。每個問題的難度等級都在0-50之間，其中0是微不足道的，而50是“未解決的研究問題”（在第一版中，Fermat的最後一個定理被列為50，但是由於Andrew Wiles證明了這一點，所以將其降級為a）。在當前版本中為45）。我認為我能夠解決大多數<20的問題-超出此範圍時遇到了很多麻煩。大多數問題都落在20-30的難度範圍內，但是Knuth的“困難”概念是主觀的，他認為屬於平均難度的問題最終使我相對較小的大腦痛苦地伸展著。我從未攀登過珠穆朗瑪峰，但我想整個磨難的感覺都差不多：在經歷磨難時會感到痛苦，但在攀登巔峰時會感到勝利。


The first third or so of the book is pure math: specifically, discrete math. As a computer programmer by trade and by education, I've always had a tumultuous relationship with math. When I was an undergraduate studying computer science, I dutifully took all the required math courses, including three semesters of brain-crushing calculus. At the time, I viewed advanced, college-level math as sort of a "dedication test": I didn't see it as practical, or useful, or applicable to my field of study, but instead as a weed-out program to see who was serious about proving their worthiness for this degree. The degree was a prize to be obtained, but you had to jump through some hoops to obtain it. Although I've since come around and accepted that math is useful — and I'm damned glad I did spend a year and a half learning calculus — Knuth manages in this book to underscore, over and over again, that math is practical and eminently applicable to the field of computer science. This was by far the hardest section of the book for me: Knuth considers a proof by induction, for example, a triviality, but I personally still have to stop and think to produce one. Some of the problems depend on what he calls "higher math", which is usually calculus with a bit of linear algebra sprinkled in, but always expertly applied. I muscled through, trying to solve each exercise. I got pretty lost in the chapter on generating functions, but I learned a lot from the section as a whole. There were plenty of topics in here that I considered myself familiar and proficient with, like number theory and binomial coefficients, but Knuth had more to teach me than I ever would have imagined.


> 本書的前三分之一左右是純數學：具體地說，是離散數學。作為從事貿易和教育工作的計算機程序員，我一直與數學有著混亂的關係。當我在大學學習計算機科學的時候，我盡職地修了所有必修的數學課程，包括三個學期的壓碎微積分。當時，我將高級的大學水平數學視為一種“奉獻測驗”：我認為它並不實用，無用或不適用於我的學習領域，而是將其作為除草程序以看看谁愿意認真證明自己的學位。學位是要獲得的獎項，但是您必須跳過一些障礙才能獲得學位。儘管我此後開始接受數學是有用的，但我感到很高興我確實花了一年半的時間學習微積分，但Knuth設法在本書中一遍又一遍地強調數學是實用且卓越的適用於計算機科學領域。對我而言，這是迄今為止這本書中最難的部分：Knuth考慮通過歸納法證明，例如瑣碎性，但我個人仍然必須停下來想一想。有些問題取決於他所說的“高等數學”，通常是微積分中摻有一些線性代數的演算，但始終要熟練地應用。我筋疲力盡，試圖解決每個練習。我在生成函數的一章中非常迷惑，但是從整個部分中我學到了很多東西。我認為自己熟悉並精通許多主題，例如數論和二項式係數，但是Knuth的教學內容比我想像的要多。


After about a hundred or so pages of pure math, he finally gets around to the computer programming part and starts by presenting a hypothetical computer architecture and associated assembler language in which all of the code samples in the remainder of the book are written. It seems that a lot of the people who complain about this series of books complain specifically about his decision to present code samples in assembler — and not just any assembler, a pretend one that he made up! Knuth gets a little defensive about that decision in the preface, pointing out that if he had written the book using the popular high-level language of the time, all of the examples in the first edition would have been in Fortran, then re-written in C for the second edition and again in Java for the third. I'm actually glad that he presented everything in a made-up, "ideal" assembler language: after having spent time learning how to code in it and understanding how it worked, there was no "magic" behind any of the examples. There are freely available emulators for the MIX assembly language (I used MDK), so you can (and I did) execute the sample programs and test out your answers to the sample exercises.

> 在大約一百頁左右的純數學學習之後，他最終進入了計算機編程部分，並開始介紹一種假設的計算機體系結構和相關的彙編語言，其中用本書編寫了其餘所有代碼示例。似乎很多抱怨這一系列書籍的人都特別抱怨他決定在彙編器中提供代碼示例的決定，而不僅僅是任何彙編器，他都是他的假裝！克努斯在序言中對此決定有所抵觸，他指出，如果他使用當時流行的高級語言編寫了本書，則第一版中的所有示例都將在Fortran中進行編寫，然後重新編寫第二版用C語言編寫，第三版用Java語言編寫。實際上，我很高興他用一種虛構的，“理想的”彙編語言來呈現所有內容：花了很多時間學習如何編寫它的代碼並理解了它的工作方式之後，所有示例背後都沒有“魔術”。有用於MIX彙編語言的免費仿真器（我使用MDK），因此您可以（並且我確實）執行了示例程序並測試了對示例練習的回答。

The later parts of the book were easier going for me, once I got the hang of Knuth's MIX assembler, but that's not to say that they were easy! For one thing, MIX is based on ancient assembler concepts. I learned assembler in the late 80's on a 6502, so I had at least some notion of registers and overflow flags and such, but MIX is closer to, say, the IBM 700 series (that predated even System/360!). The first edition of the first book was written in 1963 and follows the state of the art for computer architecture at the time. There's a lot you're going to have to learn about this architecture and development style if you're younger than about 60. Knuth thinks nothing of writing self-modifying code, for instance, and doesn't even call it out as a "trick" when he does it; to him, it seems perfectly natural. Everything operates in "words" of five (six-bit!) bytes and a lot of the instruction set is dedicated to shifting and masking these words in ways that we would use AND/OR and XOR to accomplish in a modern computer. Knuth has since updated the architecture and created MMIX for the later volumes of the book, and has stated that he plans to go back and rewrite the first three volumes to be use MMIX as well, but for now, everything in the current edition of the first three volumes is still in MIX.

> 一旦我掌握了Knuth的MIX彙編器的知識，這本書的後半部分對我來說就比較容易了，但這並不是說它們很簡單！一方面，MIX基於古老的彙編程序概念。我是在80年代後期在6502上學習彙編程序的，所以我至少對寄存器和溢出標誌有一定的了解，但是MIX更接近於IBM 700系列（甚至早於System / 360！）。第一本書的第一版於1963年編寫，遵循當時計算機體系結構的最新水平。如果您不到60歲，那麼您將需要學習很多有關此體系結構和開發風格的知識。例如，Knuth認為編寫自修改代碼沒有任何意義，甚至都不稱其為“欺騙”，當他這樣做時；對他來說，這似乎很自然。一切都以五個（六位！）字節的“字”操作，許多指令集專用於以現代計算機中使用AND / OR和XOR來完成的方式來移位和屏蔽這些字。此後，Knuth更新了體系結構，並為本書的後續版本創建了MMIX，並表示他計劃返回並重寫前三個版本，以便也使用MMIX，但到目前為止，當前版本的所有內容都將使用MMIX。前三卷仍在MIX中。


Finally, after spending half the book covering the requisite mathematics and presenting the fictitious platform on which the remaining examples are shown, he starts to cover what you might consider "basic" programming techniques like memory allocation, stacks, queues, linked lists, trees and garbage collection. I thought I knew these concepts inside and out and that there was nothing else I could possibly be taught — how wrong I was! Again, I was in awe of just how deep Knuth could manage to go down each rabbit hole to examine the limits to which all of these concepts can be pushed. Have you ever wondered how many different binary trees there are? Or how garbage collection works when there's almost no memory left for it to use? Here you'll find the distillation of 50 years of research on the boundaries of computer science.

> 最後，在花了一半的書介紹必要的數學知識並介紹了顯示其餘示例的虛擬平台之後，他開始介紹您可能考慮的“基本”編程技術，例如內存分配，堆棧，隊列，鍊錶，樹和垃圾收集。我以為我從內到外都知道這些概念，而且我別無所求-我錯了！同樣，我對Knuth能夠深入每個兔子洞以檢驗將所有這些概念推向極限的深度感到敬畏。您是否想過有多少種不同的二叉樹？還是在幾乎沒有可用內存的情況下，垃圾回收如何工作？在這裡，您將發現有關計算機科學的50年研究成果的精粹。

I've seen it suggested that these books be treated as reference books rather than read cover to cover. I'm inclined to disagree. Supposing that you had a copy on your bookshelf, and you were trying to implement a garbage collection routine. You could glance through the table of contents, see that garbage collection is discussed in section 2.3.5, and flip to the corresponding page. But if you did, you'd discover that the text refers back to some of the mathematical results that were presented and proven in previous sections (sometimes even in the exercises of the previous sections), and all of the examples are written out in MIX assembler. To make much sense of it as a reference work, you'd have to at least work through the MIX assembler description and some of the math sections. All in all, I think this book was written to be read all the way through, but also in a way that you could easily refer back to it years later, after you'd absorbed it all once.

> 我已經看到它建議將這些書視為參考書，而不是逐一閱讀。我傾向於不同意。假設您在書架上有一個副本，並且您正在嘗試實現垃圾回收例程。您可以瀏覽目錄，看到在2.3.5節中討論了垃圾回收，然後轉到相應的頁面。但是，如果您這樣做了，您會發現本文引用了上一節中介紹並證明的一些數學結果（有時甚至在上一節的練習中），並且所有示例都用MIX編寫。彙編器。為了使其更有意義，您至少必須閱讀MIX彙編器描述和一些數學部分。總而言之，我認為這本書是通篇閱讀的，但也可以使您在多年吸收完所有內容後，多年後可以輕鬆地回頭閱讀。


I've also seen people mention that they read it, but only skimmed the exercises. I guess everybody is different, but I can't fathom trying to ingest all or even most of this without working through the end-of-chapter exercises. In many cases — maybe even most — I found myself still confused after the end of the chapter, but that working through the exercises solidified the concepts that I was still unclear on in a very controlled way. Quite a few sections are nothing but proofs of complex theorems, and the exercises are there to show you what the theorems are actually useful for. Part of Knuth's brilliance is in leading you down a path of learning such that you walk away with a deep understanding of the material, and actually retain it months or even years later: but you have to follow along with him to get the most out of it. I'd go so far to say that most of the valuable content of the book is in the exercises: in spite of the page count, most of it isn't actually published!

> 我還看到人們提到他們讀了它，但只是略過了練習。我想每個人都不一樣，但是如果不進行本章末尾的練習，我無法理解嘗試吸收全部甚至大部分內容。在許多情況下，甚至是大多數情況下，本章結束後我仍然感到困惑，但是通過練習可以鞏固我仍然不清楚的概念，但這些事情仍受到控制。相當多的部分不過是複雜定理的證明，而那裡的練習將向您展示這些定理實際上是有用的。克努斯（Knuth）的光輝之處在於引導您走上學習的道路，以便您對材料有深入的了解，並在數月甚至數年後將其保留下來：但是您必須跟隨他，以充分利用該材料。它。我要說的很遠，這本書的大部分有價值的內容都在練習中：儘管有頁數，但實際上並沒有出版！

I definitely plan to finish reading the series. It may well be 2020 before I'm finished, but in the end I think it will be well worth the time. No, there are no "marketable skills" to be obtained here. There's no discussion on threading or security. There's nothing that you'll learn from Knuth that you can list on your resume. Nobody is hiring MIX programmers (if they were, I wouldn't apply anyway). It may even well be that I could have just as profitably spent the time I spent reading Knuth's "Art of Computer Programming" doing sudoku puzzles, or crosswords, or reading novels or even reading comic books, although I do feel like I learned a lot and am a better programmer for having completed it.

> 我肯定打算讀完該系列。我可能要到2020年才能完成工作，但最終我認為這將是值得的。不，這裡沒有“銷售技巧”。沒有關於線程或安全性的討論。您可以從Knuth中學到的任何東西都可以在簡歷中列出。沒有人在僱用MIX程序員（如果有的話，我還是不會申請）。即使我確實覺得自己學到了很多東西，也可能花了我寶貴的時間，花在讀Knuth的《計算機編程藝術》上做數獨難題，填字遊戲，讀小說甚至讀漫畫書。並且是完成它的更好的程序員。
