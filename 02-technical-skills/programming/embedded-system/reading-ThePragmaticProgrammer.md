# Notes on The Pragmatic Programmer

## 編程智慧

* "The best way to predict the future is to invent it." - Alan Kay
* "In programming the hard part isn’t solving problems, but deciding what problems to solve." - Paul Graham
* "Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves."
* "Documentation is a love letter that you write to your future self." - Damian Conway
* "Programming languages, like pizza, come in only two sizes: too big and too small." - Richard Pattis
* "Sometimes it's better to leave something alone, to pause, and that's very true of programming." - Joyce Wheeler
* "The most effective debugging tool is still careful thought, coupled with judiciously placed print statements." — Brian W. Kernighan
* "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so * complicated that there are no obvious deficiencies." — C.A.R. Hoare
* "Programming is like pinball. The reward for doing it is the opportunity of doing it again." - Unknown

## 第一章 務實的哲學


> 提示1：關註你的技藝。經驗與直覺，好奇心，批判性，現實主義，做一個多面手。

> 提示2：思考！思考你的工作。

* 專案與個性，採集石頭與大教堂。
* 改善，不斷做出許多小的改進。偉大的草坪需要每天的點滴護理。
* 了解來龍去脈，容易把握軟體必須做到多好。接近完美才是唯一的選項，通常需要做許多折衷方案。
* 人生是你的。
* 我活著不是為了滿足你的期望，正如你也不是因為滿足我的期望而活著。李小龍
* 人生是你的，是你在擁有，經營和創造。
* 一團糟。改變。

> 提示3：你有權選擇。

* 你可以改變組織，或是讓你換一個組織。馬丁·福勒
* 信任團隊。
* 承擔責任。

> 提示4：提供選擇，別找借口。

* 給出選擇，而不是借口。不要說搞不定，解釋一下要做些什麼才能挽回這個局面。
* 重構/原型/測試/自動化。可以解決問題嗎？
* 資源/時間/技能/書/課程/幫助。
* 當你意識到自己在說“我不知道”時，一定要接著說“——但是我會去搞清楚”。
* 軟體的熵。
* 熵增，熵減，文化，破窗。

> 提示5：不要放任破窗。

* First, Do No Harm.
* 一扇破窗：一段設計糟糕的代碼，一個讓團隊在整個項目周期內都必須要遵守的糟糕的決定——就是一切衰退的開始。
* 如果身處一個健康的團隊，你們項目的代碼是如此完美——編寫清晰，設計優良，簡潔優雅——你就會傾嚮於格外小心，不把它弄糟。
* 一定告訴自己，“不要打破窗戶”。
* 石頭湯，青蛙湯。
* 石頭湯 —— 一項協作成果。
* 青蛙湯 —— 未意識到變壞。
* 人們都覺著，加入一個推進中的成功項目更容易一些。因為只要一窺未來，大家就能團結在一起。

>  提示6：做推動變革的催化劑。

> 提示7：牢記全景。

* 你在催生變化的時候，能判別是在做石頭湯還是青蛙湯嗎？這個決定是出於主觀還是客觀？
* 違和感，情景感知。
* 夠好即可的軟體。
* 現實世界不會讓我們生産出太多完美的産品，尤其是完全沒有有bug的軟體。
* 時間、技術、急躁合力對抗著我們。
* 夠好即可的軟體就是最好的。
* 你能訓練自己寫出夠好即可的軟體 —— 對用戶、未來維護者來說夠好即可，只要好的程度讓你自己內心平靜就可以。
* 好到什麼程度？
* 讓用戶參與權衡。

> 提示8：將質量要求視為需求問題。

* 單體軟體和一個模塊化設計的係統相比，滿足質量要求所需的開發時間，是多還是少？
* 投資知識，受益最佳。
* 知識和經驗是你最重要的專業資産。
* 時效資産。
* 當你的知識價值在下降時，你對公司或者客戶的價值也在下降。
* 學習新事物的能力是你最重要的戰略資産。
* 知識組合。
* 內化。

> 提示9：對知識組合做定期投資。

* 每年學習一門新的語言。
* 每月讀一本技術書。
* 讀非技術書。
* 上課。
* 加入在地的用戶組和交流群。
* 嘗試不同的環境：windows, linux。
* 與時俱進。
* 是否在項目中使用過這些技術並不重要，甚至要不要把它們放到你的簡曆中也不重要。學習的過程將會拓展你的思維，為你打開全新可能性的大門，讓你領悟新的做事方式。
* 大衆領域，學術領域。
* 永遠不要低估商業主義的力量。

> 提示10：批判性地分析你讀到和聽到的東西。
* 批判性思維。
* 問“五個為什麼”，像小孩一樣，但是要有禮貌。
* 追蹤錢的流動更容易理清脈絡。
* 有什麼背景。
* 什麼時候在哪裏可以工作起來。
* 為什麼這是個問題。
* Go， Python，Rust，Typescript，函數式語言。
* 如果在做實現和編碼，就去讀一本設計和架構的書。如果正在較高層次做設計工作，就去讀一本講編碼技術的書。
* 我認為被人從頭打量到腳總比被人視而不見要好。

> 提示11：英語就是另一門編程語言。

* 了解聽衆。
* 對每個小組進行適當的遊說，你能讓他們都為你的項目感到興奮。
* 明白自己想說什麼。
* “這是否用正確的方式嚮我的聽衆傳達了我要錶達的東西？”精煉到不能更精煉為止。
* “現在是討論的好時機嗎？”
* 挑選風格。
* 如果隻關註內容，糟糕的外觀會毀掉你在廚房裏埋頭苦幹幾個小時的成果。
* 醜陋的文檔，一緻性，拚寫檢查。
* 讓聽衆參與。
* 做傾聽者。
* 把回憶變成一場對話，你將更有效地錶達你的觀點。
* 回應別人。

> 提示12：說什麼和怎麼說同樣重要。


> 提示13：把文檔嵌進去，不要拴在錶面。
* 網上交流，郵件要重視。

## 第二章 務實的方法

> 提示14：優秀的設計比糟糕的設計更容易變更。

* 無論什麼設計原則，都是ETC（Easier To Change）的一個特例。
* 解耦，單一職責，命名。
* ETC是一種價值觀念，不是一條規則。

> 提示15：DRY（Don't Repeat Yourself） —— 不要重複自己。

*  DRY不限於編碼。（代碼，文檔，數據，接口和調用者之間隱含語義，開發人員之間）。

> 提示16：讓複用變得更容易。

* 正交性，在計算機科學中象徵著獨立性活著解耦性。對於兩個活著多個事物，其中一個的改變不影響其他任何一個，則這些事物是正交的。
* 直升機的控制絕對不是正交的。

> 提示17：消除不相關事物之間的影響。

* 如果一個特別的功能背後的需求發生顯著改變，有多少模塊會受到影響？
* 你的設計與現實世界的變化有多大程度的解耦。
* 養成不斷質疑你代碼的習慣。只要有機會就重新組織，改善其結構和正交性。（重構）
* 啓用月度報告，去分析每個bug修複所影響的源文件的數量的趨勢。
* 面嚮對象語言和函數式語言在正交性方面有什麼差異？
* 關鍵的決定不易逆轉。
* 面嚮有彈性、適應性強的軟體生産過程。
* 與其認為決定是被刻在石頭上的，不如把它們想象成寫在沙灘上的。

> 提示18：不設最終的決定。

* 很多人都會盡力保持代碼的靈活性，但其實還要考慮在體係結構、部署和供應商集成方面的靈活性。
* 大鐵塊：自己組裝的服務器。
* 大鐵塊的聯合。
* 帶負載均衡的商用硬體集群。
* 將程式運行在雲虛擬機中。
* 將服務運行在雲虛擬機中。
* 把虛擬機換成容器再來一遍。
* 基於雲的服務器架構。
* 最後，無可避免的，有些任務又回到了大鐵塊。

> 提示19：放棄追逐時尚。

* 要讓你的代碼具備“搖滾”精神：順境時搖滾擺動，逆境時直面睏難。
* 可以把代碼的演化路線想象成裝滿了薛定諤貓的盒子：每一個決定都會導緻不同版本的未來。
* 在一個複雜多變的世界裏考慮如何命中目標，是很有趣的。
* 務實的程式員更喜歡使用相當於曳光彈的軟體。

> 提示20：使用曳光彈找到目標。
* 使用曳光彈的好處：用戶盡早獲得可以工作的東西；開發者構造了一個可以在其中工作的框架；你有了一個集成平臺；你有可以演示的東西；對進度有更好的感覺。
* 使用原型時，你的目標是探索最終係統的特定方面。如果有了一個真正的原型，最終你將扔掉驗證構思時捆綁在一起的所有東西，並總結經驗教訓，最後正確地重新編碼。
* 可以將原型看作是在發射一顆曳光彈之前進行的偵查和情報收集工作。
* 可以為這些事物做原型：架構；新功能；數據結構或外部數據的內容；第三方工具或組件；性能問題；用戶界面設計。

> 提示21：用原型學習。

* 語言之界限，即是一個人世界之界限。

> 提示22：靠近問題域編程。
>
* 收集需求、設計、編碼、PO，這套古早的方法不再有效，原因之一是它離不開一個前提 —— 我們知道需求是什麼。
* 元編程和宏。
* 內部語言：嵌入到運行時的代碼中。
* 外部語言：為這種語言編寫一個解析器。
* DSL，文本解析，BNF文法，正則錶達式，編譯原理。
* 在估算的過程中，你將會加深對程式所處世界的理解。

> 提示23：通過估算來避免意外。
>
* 計畫評審技術：樂觀的、最有可能的和一個悲觀的估算。

> 提示24：根據代碼不斷叠代進度錶。
>
* 開始給你的估算做一個記錄。每次都跟蹤一下估算的準確程度。如果誤差超過了50%，試著找到估算錯誤的原因。

## 第三章 基礎工具

* 工具變成了手的延伸。
* 純文本的威力。
* 作為務實的程式員，我們的基礎材料不是木頭或鐵塊，而是**知識**。

> 提示25：將知識用純文本保存。

* 純文本不會過時。它能夠讓你的工作事半功倍，並能假話調試和測試。
* 數據比所有創建它的工具更有生命力。
* 在異構環境中使用純文本，利遠大於弊。

> 提示26：發揮shell命令的威力。

* 專屬shell：顔色主題，提示信息，別名和shell函數，命令補全。

> 提示27：遊刃有餘地使用編輯器。


* 當你發掘出一個新的遊水特效，需要盡快把它內化為一種肌肉記憶。
* 進步，遠非寓於改變之中，而是依賴於保持。那些不能銘記過去的人，註定要重蹈覆轍。
* 版本控制：一個巨大的UNDO鍵，一個項目的時間機器。
* 版本控制，還是一個充滿協作，部署流水線，問題跟蹤，團隊交流的完整世界。

> 提示28：永遠使用版本控制。


* 某種程度上，分支就像一個小型的克隆項目。
* 調試心理學，調試是一個敏感的，情緒化的主題。
* 提示29：去解決問題，而不是責備。

> 提示30：不要恐慌。

> 提示31：修改代碼前先讓代碼在測試中失敗。

> 提示32：讀一下那些該死的出錯信息。

* 版本回退，二分法。
* 找個人，或者橡皮鴨，你一步步解釋代碼用來做什麼，這一簡單的做法能讓問題跳出營幕來暴露自己。

> 提示33：“select” 沒有出問題。

> 提示34：不要假設，要證明。

> 提示35：學習一門文本處理語言。

* 專案日記，記錄一些瘋狂的想法，有時隻是塗鴉。

## 第四章 務實的偏執

> 提示36：你無法寫出完美的軟體。

* 防禦性駕駛。
* 防禦式編程。
* 當你的程式變得更加動態時，就會發現自己像在玩拋球雜耍一樣。
* 堅持走小步。
* 沒有什麼比常識和樸實無欺更讓人吃驚。
* 與計算機打交道很難，與人打交道更是難上加難。
* 契約就是確保樸實無欺的最佳方案之一。
* 契約規定了你的權利和責任，同時也規定了對方的權利和責任。
* 雙方履約，人人受益。

> 提示37：通過契約式進行設計。

> 提示38：盡早崩潰。

* “防禦式編程是在浪費時間，讓它崩潰”。
* 一個死掉的程式，通常比一個癱瘓的程式，造成的損害要小得多。
* 自責中往往有種奢侈。我們自責時，總覺得別人無權再責備我們。

> 提示39：使用斷言去預防不可能的事情。

* 不要使用斷言來代替真正的錯誤處理。
* 點亮一盞燭火，便投出一道陰影。

> 提示40：有始有終。

* 分配資源的函數或對象，對釋放資源應負有責任。

> 提示41：在局部行動。

* 將易變得變數維持在一個小範圍內，打開資源的過程要短暫且明顯可見。
* 做預測很難，關乎未來時尤其睏難。

> 提示42：小步前進 —— 由始至終。

* 永遠小步前進，不斷檢查反饋，並且在推進前先做調整。

> 提示43：避免佔蔔。

* 只能在你看到的範圍內做計劃。

## 第五章 甯彎不摺
*  生活不會裹足不前，我們寫的代碼也不會。為了跟上當今近乎瘋狂的變化速度，我們需要盡一切努力編寫盡可能寬鬆、靈活的代碼。否則，就可能會發現，我們的代碼很快便會過時，或者因太脆弱而無法在出錯後修複，最終都可能在瘋狂沖嚮未來的過程中被拋在後面。
* decouple 解耦。
* 當我們試著單獨挑出一個事物的時候，總會發現它與宇宙中的其他一切都有關聯。（中美貿易戰）
* 當設計橋梁的時候，你想讓其保持自己的形狀，需要它們具備剛性，但當設計未來會變化的軟體時，想要的恰恰相反；你希望它是靈活的。為了更靈活，單個組件應該與盡可能少的其他組件耦合。

> 提示44：解耦代碼讓改變更容易。

> 提示45：隻管命令不要詢問。不要從對象中取出值，在加以變更後再塞回去，讓對象自己來完成這些工作。

> 提示46：不要鏈式調用方法。當訪問某事物時，使用的點號不要超過一個。

* 管道引入的耦合對修改代碼所造成的障礙，遠遠小於鏈式調用引起的耦合。

> 提示47：避免全局數據。

> 提示48：如果全局唯一非常重要，那麼將它包裝到API中。

* 讓代碼內斂一點：讓它隻處理直接知道的事情，這將有助於保持應用程式解耦，使其更容易變更。
* 事情不會隨隨便便發生，它們註定是要發生的。
* 有限狀態機。
* 狀態機基本上就是怎樣處理事件的一份規範。它由狀態組成，其中一個是當前狀態。對於每個狀態，我們列出對該狀態有意義的事件。對於每個事件，我們定義出係統新的當前狀態。
* 觀察者模式：被觀察對象，觀察者。回調函數。
* PO訂閱：推廣了觀察者模式，同時解決了耦合和性能問題。
* 在PO訂閱模式中，我們有PO者和訂閱者。它們通常是通過信道連接在一起的。信道在單獨的代碼中實現：有時是庫，有時是進程，有時是分佈式基礎設施。所有這些實現對代碼來說都是隱藏的。
* PO訂閱是一種很好的解耦異步事件處理過程的技術。
* 回響式編程、流與事件。
* 流讓我們把事件當做數據集合來對待。
* 無論事件源是什麼，圍繞事件編寫的代碼都比對應的線性代碼更容易回響，解耦效果也更好。
* 命令管道，幾乎就像一條工業裝配線：一端輸入原始數據，另一端輸出成品（信息）。

> 提示49：編程講的是代碼，而程式談的是數據。

* 如果你有面嚮對象編程的背景，那麼就會條件反射似的要求隱藏數據，並將數據封裝在對象中。結果這些對象來回摺騰，改變彼此的狀態。這就引入了更多耦合，因而也成為OO係統難於變更的一個重要原因。

> 提示50：不要囤積狀態，傳遞下去。

* 不要把數據看做是遍佈整個係統的小數據池，而要把數據看做是一條浩浩蕩蕩的河流。
* 繼承：類型組合 or 動態的行為組織。
* 繼承就是耦合。
* 繼承很快就會為了錶示類之間的細微差別而逐層添加，最終可怕地爬滿牆壁。
* 更糟糕的是多重繼承問題。

> 提示51：不要付繼承稅。
>
* 三種技術更好地解決繼承的問題：接口與協議，委托，mixin與特徵。

> 提示52：盡量用接口來錶達多態。

* 接口與協議給了我們一種不使用繼承的多態性。

> 提示53：用委托提供服務："has a" 勝過 "is a"。

> 提示54：利用 mixin 共享功能。

* mixin 不必承擔繼承稅就可以給類添加功能，而與接口結合可以讓多態不再令人痛苦。
* 物歸其所，事定期限。

> 提示55：使用外部配置參數化應用程式。


* 靜態配置，Yaml，Json。配置信息包裝在一個API後面。
* 配置服務化，配置應該是動態的，這在我們轉嚮高可用性應用程式時至關重要。
* 不要因為懶，就放棄決策，而把分歧做成配置。

## 第六章 並發

* 並發性是指兩個或者更多的代碼段在執行過程中錶現得像是在同時運行一樣。
* 並行性是指它們的確是在同一時刻一起運行。
* 並行和並發睏難的原因在於共享狀態。
* 角色模型：不允許在獨立的進程之間共享任何狀態，隻通過信道基於預定義好的簡單語義進行通信。
* 如果代碼給幾件事情強加一個順序，而這個順序對於解決手頭問題而言並非必須，就會發生時域耦合。
* 時間對我們來說有兩個重要的方面：並發性（同一時刻發生的多件事情）以及次序（時間軸上的相對位置）。

> 提示56：通過分析工作流來提高並發性。

* 使用類似活動圖輔助理清工作流。


> 提示57：共享狀態是不正確的狀態。

* 每個人都同意使用加鎖機製時才有用。
* 讓資源具備事務，多個資源的事務。
* 語言內置並發支援，Rust強化了數據所有權的概念。

> 提示58：隨機故障通常是並發問題。

* 在共享資源環境中實現並發非常難，嘗試的過程將充滿挑戰。
* 進程（角色） -- Mailbox -- 進程（角色）

> 提示59：用角色實現並發性時不必共享狀態。

* Erlang語言及其運行時是一個角色模型實現的絕佳例子。
* Erlang還提供了熱加載機製：你可以不停止運行正在運行的係統的情況下，替換該係統中的代碼。
* Erlang係統運行著一些世界上最可靠的代碼，號稱有9個9的可用性。

> 提示60：使用黑闆來協調工作流。

* 消息傳遞係統（如Kafka和NATS）所做的遠不止將數據從A發送到B。他們還提供持久化特性以及通過模式匹配的形式來檢索消息的能力。
* 消息係統可以像黑闆一樣工作。
* 面嚮架構的角色、黑闆和微服務解決方案，幫助應用程式消除了潛在的並發類型問題。但這種好處是有代價的。這些方法比較難推導出來，因為很多操作都是間接的。
* 為消息格式和API保留一個中央倉庫應該很有幫助，如果該中央倉庫能生成代碼和文檔則尤甚。
* 還需要開發出好的工具，以便在消息和事實在係統中穿行中去跟蹤它們。
* 這類係統部署和管理比較麻煩，因為有更多的組件。但這未必是壞事，在一定程度上係統力度也會變得更細，僅需單獨替換一個角色就能完成係統更新，而不必觸碰整個係統。

## 第七章 當你編碼時

* 古早觀點認為，一旦項目到了編碼階段，就幾乎隻剩一些機械工作：隻是把設計翻譯成可運行的代碼段而已。我們認為這種態度是軟體項目失敗的最重要的原因。這導緻許多係統最終變得醜陋、低效、結構糟糕、不可維護，或者根本是錯誤的。
* 編碼不是機械工作。
* 每一分鍾都有需要作出的決定。
* 隻有人類能睜著眼說瞎話。
* 害怕空白頁。

> 提示61：傾聽你內心的蜥蜴。

*  當編程舉步維艱時，其實是潛意識在告訴你有什麼地方不對勁。

> 提示62：不要依賴巧合編程。

> 提示63：評估算法的複雜度。

> 提示64：對估算做測試。

* 如果現在不進行重構，那麼以後就需要投入更多的時間解決問題，因為需要處理更多的依賴關係。

> 提示65：盡早重構，經常重構。

> 提示66：測試與找 Bug 無關。

> 提示67：測試是代碼的第一個用戶。

> 提示68：既非自下而上，也不自上而下，基於端到端構建。

* 構建軟體的唯一方法是增量式的。
* 首先測試模塊的子組件，一旦驗證了子組件，就可以繼續測試模塊本身。

> 提示69：為測試做設計。

> 提示70：要對軟體做測試，否則隻能留給用戶去做。

> 提示71：使用基於特性的測試來校驗假設。

* 基於特性的測試讓你從不變式和契約的角度來考慮代碼；你會思考什麼不能改變，什麼必須是真實的。
* 出門在外註意安全。
* 好籬笆造出好鄰家。
* 行百裏者半九十。
* 分析代碼中的那些可能出錯的路徑，並將其添加到測試套件中。你要考慮傳入錯誤的參數、泄露的資源或資源不存在等此類事情。

> 提示72：保持代碼簡潔，讓攻擊面最小。

> 提示73：盡早打上安全補丁。

* 曆史上（到目前為止），最嚴重的數據泄露是由係統更新滯後造成的。
* 經過良好審查、徹底檢查、維護良好、經常更新、最好是開源的庫和框架。
* 名不正，則言不順；言不順，則事不成。
* 應用程式、子係統、模塊、函數和變數起名字很重要，因為它們透漏出你的很多意圖和信念。
* “我這一創造的動機是什麼？” 這是一個強有力的問題，因為它把你從立即解決問題的心態中拉出來，讓你看到更大的圖景。
* 大腦很尊重書面文字。我們需要確保使用的名字不辜負這一點。
* 在計算機科學中，隻有兩件難事：緩存失效和命名。
* 一緻性。
* 愚蠢地使用一緻性是無知的妖怪......。

> 提示74：好好取名；需要時更名。

## 第八章 項目啓動之前

* 所謂完美境界，並非加無可加，而是減無可減。

> 提示75：無人確切知道自己想要什麼。

*  盡量要在開始之前就理解整個問題。

> 提示76：程式員幫助人們理解他們想要什麼。

* 典型的客戶會帶著需求來找我們。這種需求可能是戰略性的，但更可能是戰術性的：對當下面臨問題做的一個回應。
* 最初對需求的申明，往往並非絕對化的要求。客戶可能沒有有意識到這一點，但一定希望你能一起去探索。
* 這既是一個演繹性過程，又是一個創造性的過程：你會靈機一動，為一個更好的解決方案添磚加瓦。
* 需求是一個過程。

> 提示77：需求是從反饋循環中學到的。

> 提示78：和用戶一起工作以便從用戶角度思考。

> 提示79：策略即元數據。

* 當我們需要把它們所說的東西，擴展為一份法律文件時，就好像是在流沙上建造一座難以置信的複雜城堡。
* 需求不是架構；需求無關設計，也非用戶界面；需求就是需要的東西。
* 我們可以做些什麼來防止需求蔓延開呢？
* 答案（又一次）是反饋。

> 提示80：使用項目術語錶。

> 提示81：不要挑出框框思考 —— 找到框框。

*  在面對無法解決的難題時，識別出真正的約束。可以問自己：“必須這樣做才能搞定嗎？必須搞定它嗎？”
* 幸運眷顧有準備的人。
* 在日常生活中，將什麼行得通什麼行不通反饋給大腦，是供養大腦的最好方法。我們描述過一個好方法，就是記錄專案日記。
* 一個不可能完成的項目，還有一個可笑的最後期限。
* 但是這個項目獲得了巨大的成功：我們可以不斷地提問、澄清、決策和演示。
* 康威定律：設計係統的架構受製於産生這些設計的組織的溝通結構。
* 結對編程。群體編程。

> 提示82：不要一個人埋頭鑽進代碼中。

* 敏捷是一個形容詞：它指嚮你做事情的方式。

> 提示83：敏捷不是一個名詞；敏捷有關你如何做事。

* 敏捷宣言：A. 個體和互動高於流程和工具。B. 工作的軟體高於詳盡的文檔。C. 客戶合作高於契約談判。D. 回響變化高於遵循計劃。
* 這些價值觀，是由不斷發現更好軟體生産方法的行為，所激發和顯露出來的。這不是一份靜態的文檔，它是對生産過程的建議。
* 永遠不可能有一個叫敏捷的工藝流程。
* 這些價值觀，不會告訴你該做什麼。當你自己決定要做點什麼的時候，它們會告訴你要去追尋什麼。
* 簡單的反饋循環並不僅僅適用於軟體。回想一下最近做的軟體之外的決定。如果事與願違，那麼假設一切可以回退，就此是否有什麼能改進之處？


## 第九章 務實的項目

* 隨著項目的進行，我們需要從個人的哲學和編碼問題，轉移到更大的、項目規模的問題。
* 一旦項目不隻你一個人，就需要建立一些基本規則，並依次將項目的各部分分配出去。
* 在務實的團隊中，我們將展示如何在尊重務實哲學的基礎上做到這一點。
* 軟體開發方法的目的是幫助人們一起工作。
* 在L組裏，斯托佛管理著六個一流的程式員，這在管理上的挑戰與養貓差不多。
* 這些方法是否也適用於團隊，甚至是由一群意誌堅強、獨立個體構成的團隊呢？這裏可以響亮地回答“可以！”成為一個務實的人，有很多優勢，但是如果這樣的個體能在一個務實的團隊中工作，優勢會成倍增* 加。
* 團隊是一個小而穩定的實體。
* 50個人就不算團隊，算是部落。
* 隨著團隊規模的增長，溝通路徑以 O(n%2) 的速度增長，其中n  是團隊成員的數量。在更大的團隊中，溝通開始變得無效。
* 務實的團隊很小，充其量也就10~12人左右。成員很少進出。每個人都很了解彼此，相互信任，互相依賴。

> 提示84：維持小而穩定的團隊。

* 如果團隊不鼓勵開發者在這些修複工作上花費時間，那麼問題就會進一步惡化。
* 團隊作為一個整體，不應該容忍破碎的窗戶 —— 哪些沒有人去修的小問題。
* 在一些團隊方法中，團隊會設一個“質量官” —— 有這個人對交付的産品的質量負責。這顯然是荒謬的：質量隻能來自團隊每個成員的貢獻。質量是內在的，無法由外在保證。
* 即使是最用心的團隊，也可能對項目中的重大變化渾然不覺。
* 如果團隊對改進和創新是認真的，那麼就需要將其排入日程錶。

> 提示85：排上日程以待其成。

* 團隊自身也在組織中；團隊作為一個實體，需要與世界的其他部分進行清晰的溝通。
* 在外人看來，最糟糕的項目團隊就是那些看起來悶悶不樂、沈默寡言的團隊。
* 他們的會議組織混亂，沒有人願意發言。電子郵件和項目文檔一團糟：每一個人使用著不同的術語，沒有有哪兩樣東西看起來是相同的。
* 優秀的項目團隊有獨特的個性。人們期待與他們會面，因為知道他們準備的很充分，會讓他們錶現得每個人都心情愉悅 。
* 他們生成的文檔是清晰、準確和一緻的、
* 團隊用同一個聲音說話，甚至可能還不乏幽默感。
* 有一個簡單的營銷技巧，可以幫助團隊作為一個整體對外交流：創建一個品牌。當開始一個項目時，為它起一個名字，最好是一個稀奇古怪的名字。
* 係統很少共享，而且有很多重複的功能。

> 提示86：組織全功能的團隊。

* 有一個確保一緻性和準確性的好方法，那就是將團隊所做的一切自動化。
* 《人月神話》
* 他們模仿的是形式，不是內容。
* 人類學家稱之為貨物崇拜。
* 在很多時候，我們就是這些島民。
* 有些團隊，宣稱在使用Scrum，但是他們每周隻做一次站立會議。
* 他們的投資僅僅浮於神器的錶面 —— 甚至隻限於名字，就好像“站立”或“叠代”這些詞是某種邪教的咒語一樣。
* 不出所料，他們也沒有有吸引到真正的魔力。
* 特定的神器，以及浮於錶面的結構、策略、流程和方法是不夠的。

> 提示87：做能起作用的事，別趕時髦。

* 同一尺寸無法適應所有人。
* 許多認證課程實際上更加糟糕：它們建立在學生能夠記住並遵循規則的基礎之上。
* 你想要的並非如此，你需要有能力超越現有的規則，發掘有利的可能性。
* 這與“但是Scrum/精益/看闆/XP/敏捷是這樣做的.....”的心態大為不同。
* 真正的目的：和任何目標一樣，最關鍵的是要保持瞄著正確的方嚮。
* 如果交付周期是幾年，試著把周期縮短到幾個月。如果是幾個月，就減少到幾周。
* 當這樣做在業務上有意義時，才有必要在用戶需要時及時交付。

> 提示88：在用戶需要時交付。

* 不要輕信我們的話，自己調查並嘗試一下這些方法。
* 不過務必小心，不要做過頭。
* 過度投資於任何一種特定的方法，會讓你對其他方法視而不見。
* 當你習慣於一種方法時，很快就看不到其他的出路了。
* 你已經僵化，變得不再能快速適應。
* 文明的進步是增加那些不需要思考就能完成的重要操作來實現的。
* 務實的入門套件：版本控制，回歸測試，完全自動化。

> 提示89：使用版本控制來驅動構建、測試和PO。

* 尋找Bug有點像網捕魚。我們使用精細的小漁網（單元測試）來捕捉小魚，使用大的粗漁網（集成測試）來捕捉食人魚。

> 提示90：盡早測試，經常測試，自動測試。

> 提示91：直到所有的測試都已運行，編碼才算完成。

> 提示92：使用破壞者檢測你的測試。

* 在編寫測試時，確保在應該發出警報時警報會響。

> 提示93：測試狀態覆蓋率，而非代碼覆蓋率。

> 提示94：每個Bug隻找一次。

> 提示95：不要使用手動程式。

* 你的夜間構建或者持續構建是自動化的，但是部署到生産環境中的過程卻沒有有自動化，是這樣嗎？為什麼？那臺服務器有什麼特別之處？
* 對應用程式獨立於GUI之外的邏輯進行測試，是否太難了？這說明了和GUI有關的什麼問題？是耦合問題嗎？
* 真正有意義的是這些對業務價值的期望，而不僅僅是軟體項目本身。軟體隻是達到這些目的的一種手段。

> 提示96：取悅用戶，而不是只要交付代碼。

* 或許你的頭銜隻是“軟體開發者”或“軟體專案師”的某種變體，而事實上這個頭銜應該是“解決問題的人”。這就是我們所做的，也是一個務實的程式員的本質。
* 傲慢與偏見。
* 務實的程式員不會逃避責任。
* 相反，我們樂於接受挑戰，並讓自己的專長廣為人知。如果我們正在負責一個設計，或一段代碼，那麼這是一份值得自豪的工作。

> 提示97：在作品上簽名。

* 一個務實的程式員。

## 跋

* 長遠來說，我們塑造生活，塑造自己。直至死亡為止，這過程永不會完結。最終我們總要為所做的抉擇負上責任。
* 從那以後的二十年間，軟體加速發展，不僅突破了單純上午機器的範疇，甚至可以說接管了世界。
* “程式員，就像詩人一樣，幾乎僅僅工作在單純的思考中。他們運用自己的想象，來建造自己的城堡”。
* 我們從一張白紙開始，幾乎可以創造任何我們能想象到的東西。我們創造的東西可以改變世界。
* 我們真正在建設未來，這是一股巨大的力量。
* 我們隱約看到烏托邦未來的可能性。
* 對於我們交付的每一段代碼，我們有義務問自己兩個問題：1) 我已經保護好用戶了嗎？2) 我自己會用它嗎？
* 提示98：先勿傷害。
* 提示99：不要助紂為虐。
*  這取決於你。正是你的想象力、你的希望、你的關註，為未來20年甚至更長時間的構建，提供了純淨的思想基礎。
* 你正在為自己和子孫後代建造未來 —— 這是你的職責所在，去創造一個讓所有人心嚮往之的宜居未來。當你做的事情違背了這個理想時，要敢於承認，並有勇氣說“不！”對可以擁有的未來充滿憧憬，才有動力去創造它。即使是空中樓閣，也要每天為它舔磚加瓦。
* 我們都有精彩的人生。

> 提示100：你要為自己的人生做主。精心營造，與人分享，為之喝彩。好好享受吧！
