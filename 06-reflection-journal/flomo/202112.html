<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>flomo · 浮墨笔记</title>
        <style type="text/css">
        body { background:#FAFAFA; }
        .memos { width:600px; margin:0 auto; }
        .memos h1 { margin-top:30px; }
        .memo { margin:20px 0; background:#FFF; padding:20px; border-radius:6px; }
        .memo:hover { box-shadow: 0px 2px 16px #DDDDDD; }
        .memo .time { color:#8D8D8D; font-size:12px; }
        .memo .content { color: #323232; font-size: 14px; }
        .memo .content p { line-height:1.8; min-height:20px; margin:0; }
        .memo .content ul,
        .memo .content ol { padding-inline-start: 20px; margin: 0; }
        .memo .content li { line-height: 1.8; }
        .memo .files img { width:100%; border:1px solid #E6E6E6; border-radius: 4px; margin:6px 0; }
        </style>
    </head>
    <body>
        <div class="memos">
            <h1>202112 @ flomo</h1>
                        <div class="memo">
                <div class="time">2021-12-30 09:52:59</div>
                <div class="content">
                    <p>第二个前提是你有一技之长，你靠它挣钱，而不是靠投资收益过日子。投资是用来保护你用一技之长挣来的收入，不受通胀的侵蚀，而不是替代你的一技之长。</p><p></p><p>来自“02 投资需要知道的所有事 | 30天认知训练营·2020”</p><p></p><p>#得到</p><p>https://www.dedao.cn/share/trialReading?trialReadingId=69G8Mv4dx7AJg3EL1rQOeWYg4SY7TbbNMS0a8o4GYWJKD6wa50NezbR2DoXWjkny&type=65</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-30 09:46:39</div>
                <div class="content">
                    <p>投资容易犯的四个错误</p><p></p><p>第一，认识你自己，不要以为自己特殊。</p><p></p><p>你是谁？你是个普通人。至少在投资这件事上，你是个普通人。不光是你，绝大多数人都是普通人。</p><p></p><p>你在这个问题上往往是自相矛盾的。一方面，既然你焦灼、不知所措，你当然是个普通人；另一方面，你隐隐约约觉得自己不至于那么普通，你要么觉得自己运气好，要么觉得自己学得快，要么觉得自己认识点大人物，要么觉得别人比你还傻。总之你觉得自己应该超过平均水平。</p><p></p><p>可是巧了，所有人都认为在所有事情上自己超过平均水平，在投资这事上也不例外。而这就是你要避免的第一个错误，放弃幻想，接受自己是普通人这个事实。</p><p></p><p>第二，对普通人来说，投资不是为了进攻，而是要为了防守。</p><p></p><p>对普通人来说，学习一种技能，打磨一个长处，找到一份工作，自食其力，这样做的成功率是95%。这个数字是怎么来的呢？中国社会的失业率也就是5%。反过来说，炒股为生的成功率肯定不到1%。这就是普通人面对的基础概率。你愿意站到95%一边，还是1%那一边？</p><p></p><p>之所以有过多的人对投资抱有过高的期待，是因为他们希望投资能改变命运。这是个根本性的幻觉。指望用投资改变自己命运的人，99%是帮别人改变了命运。</p><p></p><p>你想要改变命运，有条大路好走。提升你的技能，进一步发挥你的长处，把工作做到比你的同事更好，获得一份更好的工作，然后寻找一个更高的目标。这条路的成功率没有95%那么高了，但10%总是有的，如果你总是在十个人中脱颖而出，到塔尖并不需要爬上多少级台阶。</p><p></p><p>投资不能帮你进攻，但能帮你防守。在你的人生周期当中，收入曲线大体上是先少后多再少，与你的需求曲线不完全匹配。收入高的时候有积累，用于收入少时的消费。防守的意思就是保住你的积累，让它免受通货膨胀的侵蚀，使它在你需要动用的时候，仍然具有与你获得它时一样的购买力。普通人最应该端正的对投资的态度，就是换成防守心态，底线目标设定在战胜长期通胀水平。</p><p></p><p>如果你接受不了，说你想的是逆天改命，而我刚才说的正路太长太远。那赌客在拉斯维加斯赌场的胜率，比你在股市里想要逆天改命的胜率要高。而且至少打的是明牌，庄家占了你多大便宜明明白白。</p><p></p><p>重要的事情再强调一次：逆天改命的最好办法就是提升技能，发挥长处，把工作做得更好，步步攀上更高的目标。</p><p></p><p>这条路不疾而速，说它最好，只是说它对普通人来说相对最宽，爬上去的概率最高，但并不意味着它是大概率事件。改命的人总是少数，社会金字塔先天注定了这一点。但你不要因为它看上去慢，机会仍然不够大，就看不到其他的路更险更窄。</p><p></p><p>这场防守战不是一时一地能打完的，将持续你成年以后的一生。你的人生积累不论是多还是少，始终有群狼环伺，骗子盯着，庄家盯着，首富们也盯着，不要以为他们的钱比你多就不盯着你，要不然他们的钱是从哪里来的？</p><p></p><p>好在，只要你不跟那些狼抢肉——因为他们抢的就是你的肉，只要你躲开他们，设定与自己的人生匹配的投资周期，选择恰当的多元化策略，你就能战胜通胀，保住自己一生劳动的果实。具体我在《投资需要知道的所有事》那一课里讲了，你可以跳转过去了解。</p><p></p><p>第三，中国人资产组合的普遍多元化严重不足。</p><p></p><p>这里不多讲，只再强调一点：中国人资产组合的多元化严重不足，这就是我要说的第三点。</p><p></p><p>从多元化这个维度看，中国人的资产组合有几个严重问题。</p><p></p><p>第一个问题是过度配置于房子。</p><p></p><p>掏光上下三代人六个钱包，出得起首付就叫买得起房，房贷的事慢慢再说。本质上是寄希望于房价永远涨，而这希望肯定有一天会破灭。</p><p></p><p>第二个问题是跨区域多元化不足。</p><p></p><p>一个合理的组合当中必须要有点境外资产，这不是说要你去国外买房，有能力这样做的人是极少数。而是指中国金融急需进一步开放，不仅要把海外资金引入中国资本市场，也要把全球领先的、超低费率、极广覆盖的良心基金管理公司引入中国，为中国人合理化组合资产安排一个去处。我估计这事一时半会儿仍然不会发生，但它确实是中国人民所急需。</p><p></p><p>第三个问题是过度投资于子女教育。</p><p></p><p>它在一定程度上是受投资焦虑驱动的。钱没去个安全妥当的去处，那就花在孩子身上吧。它在很大程度上是由军备竞赛逻辑驱动的。别人在孩子身上花多少钱，你不花这么多钱的话，孩子就输在起跑线上了，而终点留着的好位置就那么几个。</p><p></p><p>作为两个孩子的父亲，我也在这场军备竞赛之中，感同身受，理智与感情交织。别的也不多说了，就强调从资产组合的角度来讲，它已经过度超配了。各位家长，为了人生资产组合的健康，我们都往回调调吧。大家一起往回调调，大家的日子都能好过一点。</p><p></p><p>第四个问题是几乎没有灾难准备。</p><p></p><p>前面讲过，世事无绝对。你诚实劳动，合理投资，95%的时候你能保住劳动果实，安度自食其力的一生，如果你是那优秀的10%，还能攀上人生阶梯的更高处。但仍然可能有那么一些时候，大潮袭来，席卷一切。这时候没有什么投资组合能帮你保住劳动果实。历史一再告诉我们，现实是个王八蛋，说翻脸就翻脸，以万物为刍狗。谁拿它也没有办法。这时候，你需要的是灾难准备。</p><p></p><p>关于灾难准备，有这么几个要点：你不能完全不作灾难准备，因为万一灾难发生，有无准备则意味着生与死的差别；你必须在天气晴朗的时候就作准备，因为灾难来临时一切就都已经晚了；你也不能过度准备，因为灾难到来的概率毕竟是极为微小；你也别靠金融工具，特别是衍生品作灾难准备，因为真正需要动用灾难准备时，支撑衍生品的那个体系可能已经摇摇欲坠。</p><p></p><p>任何灾难准备不仅要预判系统风险，还要意识到交易对手风险。你准备了灾难，但你的对手没准备。灾难来了，你的对手完蛋了，你所作的准备就跟它一起烟消云散。比如说，你买了保险，但是当灾难来临的时候保险公司不在了。</p><p></p><p>灾难准备跟投资有关，但不是投资，尽管它有可能运用有投资属性的工具，比如黄金。人类历史上，每当灾难降临时，黄金对一切资产升值，而食物对黄金升值。其实今天不少人的投资组合中有黄金，但他们仍然是将黄金当作一种投资品而不是灾难准备。两者存在一个关键差别：投资品以收益为目的，灾难准备不以收益为目的，就是准备着灾难万一来临——即使大萧条重现，甚至哪怕战争来临，所有投资组合全部失效，你还有点救命的安排。到目前为止，人类共同认可的灾难准备就是黄金。</p><p></p><p>来自“01 投资六忌 | 30天认知训练营·2020”</p><p></p><p>#得到</p><p>https://www.dedao.cn/share/trialReading?trialReadingId=DaZv1E9YrMbzLmONq2P97MNE5hBrt88Ayh1m0jAJ9E6dkYpxoWejyGkRg5n3VX40&type=65</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-29 15:06:46</div>
                <div class="content">
                    <p>#project/llsw Proactive Debugging</p><p></p><ul><li><p>Stacks and Heaps</p></li><li><p>Seeding Memory</p></li><li><p>Wandering Code</p></li><li><p>Special Decoders - Another option is to build a special PAL or PLD, connected to address and status lines, that flags errant bus transactions. Trigger an interrupt or a wait state when, say, the code writes to ROM.</p></li><li><p>MMUs</p></li></ul><p></p><p>src: http://www.ganssle.com/articles/proactive.htm</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-29 13:01:12</div>
                <div class="content">
                    <p>#project/llsw Stamp Out Bugs!</p><ul><li><p>How to use proactive debugging to find bugs fast. https://flomoapp.com/mine/?memo_id=MTI0MDM3MTY</p></li><li><p>Managing bugs to get good code fast.</p></li><li><p>Quick code inspections that keep the schedule on-track.</p></li><li><p>Cool ways to find hardware/software glitches</p></li></ul><p></p><p>src: http://www.ganssle.com/onsite.htm</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-29 08:19:12</div>
                <div class="content">
                    <p>#reading/legacy-code seam types</p><p></p><ul><li><p>預處理期 Preprocessing Seams</p></li><li><p>連接期 links Seams</p></li><li><p>物件 object Seams</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-29 08:17:06</div>
                <div class="content">
                    <p>#reading/legacy-code Enabling Point 激活點</p><p></p><ul><li><p>Every seam has an enabling point, a place where you can make the decision to use one behavior or another.</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-26 11:07:10</div>
                <div class="content">
                    <p>#inbox 只要是比賽，大家都會把輸贏看得很重要</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-26 10:39:57</div>
                <div class="content">
                    <p>#project/jazz-redesign 階段性 code review</p><p></p><ol><li><p>pull in rs9116</p></li><li><p>add ANT</p></li><li><p>close BT classic</p></li><li><p>fix CDP</p></li><li><p>add sync 2.0</p></li><li><p>performance?</p></li><li><p>smoke test - wireless test case?</p><p></p></li></ol>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-24 16:36:46</div>
                <div class="content">
                    <p>#project/workflow 如何ww/aisa 齊步開發發行軟體</p><p></p><ul><li>這是 continue integration 的部份嗎？</li><li>ci 是system level的功能驗證</li></ul><p>功能需求是什麼？如何在asia版完成驗證？</p><p></p><p>src: 2021/12/23 JW 工程部年報</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-23 14:03:07</div>
                <div class="content">
                    <p>#reading/legacy-code Object Seam 無痛解依賴</p><p></p><ul><li><p>One of the biggest challenges in getting legacy code under test is <strong>breaking dependencies.</strong></p></li><li><p>The seam view of software helps us see the opportunities that are already in the code base.</p></li><li><p>If we can replace behavior at seams, we can selectively exclude dependencies in our tests.</p></li><li><p>We can also run other code where those dependencies were if we want to sense conditions in the code and write tests against those conditions.</p></li><li><p>www.mockobjects.com</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-23 13:37:54</div>
                <div class="content">
                    <p>#project/jazz-redesign 查 build.py 的node_deps 是怎麼找到dependency</p><p></p><ul><li><p>build.py</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.node_deps&nbsp;=&nbsp;{}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Dict&nbsp;of&nbsp;node&nbsp;dependencies&nbsp;found&nbsp;by&nbsp;:py:meth:`waflib.Task.Task.scan`&nbsp;(persists&nbsp;between&nbsp;build&nbsp;executions)"""</p><p></p><ul><li><p>deps_why.py&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></li></ul><p>&nbsp;bld.node_deps&nbsp;are&nbsp;actually&nbsp;outdated&nbsp;and&nbsp;from&nbsp;the&nbsp;last&nbsp;build,&nbsp;but&nbsp;it&nbsp;doesn't</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;updated&nbsp;until&nbsp;later&nbsp;in&nbsp;the&nbsp;build,&nbsp;so&nbsp;we'll&nbsp;use&nbsp;outdated&nbsp;deps&nbsp;so&nbsp;the</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;can&nbsp;print&nbsp;out&nbsp;before&nbsp;the&nbsp;tasks&nbsp;build</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_deps&nbsp;=&nbsp;self.generator.bld.node_deps[self.uid()]</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE0NDY0MzU</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-22 17:55:09</div>
                <div class="content">
                    <ul><li>她说，其实养育孩子没那么复杂，只需要掌握几条基本原则：信任（Trust）、尊重（Respect）、独立（Independence）、合作（Collaboration）、善意（Kindness）</li><ul><li>“TRICK”原则</li><li>而这本书就是对这套原则的详细阐述。</li></ul><p></p><p>来自“《硅谷超级家长课》| 徐学勤解读 | 时长：26分40秒”</p><p></p><p>#得到</p><p>https://m.igetget.com/share/topic?id=oqeOBXwd7PyL0YVJ6Wm9NkJDax15l6</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-22 16:48:12</div>
                <div class="content">
                    <p>#project/jazz-redesign </p><p></p><p>v WLN_CONFIG_ENABLE</p><p>x HWM_WIFI_SUPPORT</p><p>x NETNAME_SUPPORT</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-22 10:15:17</div>
                <div class="content">
                    <p>#project/workflow Python and Tkinter Programming</p><p></p><p>src: Python and Tkinter Programming</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-21 17:19:29</div>
                <div class="content">
                    <p>#reading/legacy-code LLSW 的assert 是否有用？</p><p></p><p>mock object 的assert 是用在unit test的情境，llsw 可能不適用？出asert log嗎？</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE4NDQ4MTU</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-21 14:52:11</div>
                <div class="content">
                    <p>#reading/legacy-code Mock object</p><p></p><p>Fakes are easy to write and are a very valuable tool for sensing.</p><p>If you have to write a lot of them, you might want to consider a more advanced type of fake called a mock object. Mock objects are fakes that perform assertions internally</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE4NDQ1MjE</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-21 14:47:53</div>
                <div class="content">
                    <p>#reading/legacy-code fake object</p><p></p><ul><li><p>A fake object is an object that impersonates some collaborator of your class when it is being tested.</p></li><li><p>If we can use information like that to help us localize </p><p>errors, we can save an incredible amount of time.</p></li><li><p>When we write tests for individual units, we end up with small, well-understood pieces. This can make it easier to reason about our code.</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-20 15:07:22</div>
                <div class="content">
                    <p>#family 親密關系行動清單</p><p></p><p>行动清单第十条：给他一个拥抱，并问问他辛不辛苦。</p><p></p><p>经营亲密关系，其实并不需要那么复杂，一个简单的拥抱，一句简单的问候，只要是用心的，就足以让彼此感到温馨。而最可悲的是，我们知道这个道理，却总是因为各种各样的原因忽略了它。</p><p></p><p>来自“《爱，需要学习》新书发布｜送你一份亲密关系行动清单 | 陈海贤·家庭关系21讲”</p><p></p><p>#得到</p><p>https://www.dedao.cn/share/trialReading?trialReadingId=L5Vezmo0yZ7gYjMEqxw2j8OaoI2Acbg2MiZzGD9VNByERXw6AGva19KWBNrXnR24&amp;type=65</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-20 08:32:29</div>
                <div class="content">
                    <p>#project/jazz-redesign #reading 參考書</p><p></p><p>如何理解和修改legacy code -</p><ul><li><p>Working Effectively with Legacy Code #reading/legacy-code</p></li><li><p>Effective Debugging #reading/debugging</p></li><li><p>Debug it https://flomoapp.com/mine/?memo_id=MTE3NDU5MTA</p></li><li><p>軟件驅魔：調試和優化遺留代碼的藝術</p></li></ul><p></p><p>軟體專案開發</p><ul><li><p>Code Complete</p></li><li><p>Rapid Development</p></li><li><p>Software Project Survival Guide</p></li><li><p>Applying UML and Patterns ?</p></li><li><p></p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-20 08:29:58</div>
                <div class="content">
                    <p>#reading/debugging 软件调试修炼之道 (debug it)</p><p></p><p>https://zwiley.github.io/mybook/debug/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/book/</p><p></p><p>1. 山重水复疑无路</p><ul><li><p>有效的调试步骤：</p><ul><li><p>弄清楚为什么运行异常</p></li><li><p>修复问题</p></li><li><p>避免破坏其他部分</p></li><li><p>保持或者提高代码总体质量（可读性，架构，测试覆盖，性能等）</p></li><li><p>确保同样问题不要再次发生</p></li></ul></li><li><p>实证方法：构建实验，观察结果</p></li><li><p>澄清问题：</p><ul><li><p>发生了什么，应该发生什么</p></li><li><p>一次一个问题</p></li></ul></li><li><p>先检查简单的事情</p></li><li><p>核心调试过程：</p><ul><li><p>问题重现</p></li><li><p>问题诊断</p></li><li><p>缺陷修复</p></li><li><p>反思，吸取教训</p></li></ul></li></ul><p></p><p>2 重现问题</p><p>2.1 重现第一，提问第二</p><p>如何重现：</p><ul><li><p>明确开始要做的事情（比如缺陷报告的步骤）</p></li><li><p>抓住重点</p></li></ul><p>控制因素：</p><ul><li><p>软件本身</p></li><li><p>运行环境</p></li><li><p>提供的输入</p></li></ul><p>2.2 控制软件</p><p>2.3 控制环境</p><p>可能包含所有环境</p><p>2.4 控制输入</p><p>推测可能输入:</p><ul><li><p>回溯工作</p></li><li><p>探测可能输入值</p></li><li><p>边界分析</p></li><li><p>分之覆盖</p></li><li><p>利用错误条件</p></li><li><p>引入随机性：模糊测试；生成模糊器；变异模糊器</p></li><li><p>记录输入值</p></li><li><p>日志框架。可以开启 or 关闭；日志级别；上下文（代码行数等）；分析工具（ELK）</p></li><li><p>外部日志。代理服务器等</p></li><li><p>负载和压力。有些缺陷只有在某种压力才表现出来（高负载网络流量，有限的可用内存）</p></li></ul><p>2.5 改进问题重现</p><p><strong>2.5.1 最小化反馈周期。编辑-执行-重新问题时间最短</strong></p><ul><li><p>尽可能简单，通过二分法快速定位</p></li><li><p>自动化最小输入</p></li><li><p>最大限度减少所需时间，比如营造资源耗尽的局面。</p></li></ul><p><strong>2.5.2 不确定缺陷变为确定</strong></p><p>软件之美在于确定性，但是不确定性从哪里来？</p><ul><li><p>开始于不可预知的初始状态。从未经初始化的内存读取数据(强制初始化，或者内存完整性检测软件)</p></li><li><p>与外部系统交互: 精确控制从外部系统接收了什么</p></li><li><p>故意使用随机性: 伪随机数</p></li><li><p>多线程: 通过 sleep 等增加出现竞争的可能性</p></li></ul><p><strong>2.5.3 自动化</strong></p><ul><li><p>自动化测试</p></li><li><p>重放日志</p></li></ul><p>2.6 无法重现怎么办</p><ul><li><p>缺陷真的存在么？</p></li><li><p>在相同区域解决不同问题</p></li><li><p>让其他人参与其中。不同人的视角</p></li><li><p>充分利用用户群体</p></li><li><p>推测法：逻辑推理，想象出错的可能性</p></li></ul><p>3 诊断</p><p>3.1 不要急于动手，试试科学方法</p><ul><li><p>调试方法：</p></li><li><p>根据你对软件运行情况的理解，提出一个可以导致这种情况的假设</p></li><li><p>设计一个实验，证明假设是否正确</p></li><li><p>如果无法证明你的假设，重新设计然后再次实验</p></li><li><p>如果实验支持你的假设，继续证明，知道能够证明或者证伪</p></li><li><p>实验必须起到验证的作用。(与他人争辩试图推翻你的假设)</p></li><li><p>每次只做一个修改。多处修改可能导致错误的结论。</p></li><li><p>记录你做的调试。定期回顾你已经尝试过的实验和学到的东西，使用日记簿或者电子笔记。</p></li><li><p>不要忽略任何细节。凡是你不明白的都是潜在的缺陷。(Anything that you don’t understand is potentially a bug)</p></li><li><p>写出假设。曾经做过的假设写到纸上</p></li><li><p>可以跟踪详细信息</p></li><li><p>确保不会忘记需要做的事情</p></li><li><p>短暂休息，可以尝试头脑风暴</p></li></ul><p>3.2 相关策略</p><p><strong>3.2.1 插桩</strong></p><p>使用日志，但是不要引入额外的副作用影响了原始代码逻辑。增加日志的时候，不要同时修改代码逻辑。</p><p><strong>3.2.2 分而治之</strong></p><p>二分法，排除一部分模块或者代码的问题。</p><p><strong>3.2.3 源码控制工具</strong></p><p>git 找出历史提交，分析引入缺陷的提交</p><p><strong>3.2.4 聚焦差异</strong></p><p>找到特殊用例，缺陷的边界</p><p><strong>3.2.5 向他人学习</strong></p><p>网络搜索，同事求助</p><p><strong>3.2.6 奥卡姆剃刀</strong></p><p>其他条件相同情况下，最简单的解释是最好的。</p><p>3.3 调试器</p><p>代码检查，断点，单步调试，检查运行状态</p><ul><li><p>开发初期调试器非常有用</p></li><li><p>让代码以特定方式运行</p></li><li><p>探究看不懂的代码</p></li></ul><p>随着经验增加和TDD 思想出现，调试器使用会变少</p><p>3.4 陷阱</p><ul><li><p>你做的修改是正确的么？如果没有，说明你没修改到点子上。尝试引入明显的失败比如断言让其暴露出来</p></li><li><p>验证假设。思维定势造成的先验假设可能会让你得不到结果</p></li><li><p>多重原因。问题有时候是复杂的，</p></li><li><p>对问题进行隔离，找到一个方法重现缺陷。</p></li><li><p>先找同一个区域内其他较明显的缺陷，扫清障碍，让缺陷更加明显</p></li><li><p>查出变化并且控制它。第三方系统或者数据库。</p></li></ul><p>3.5 思维游戏</p><ul><li><p>旁观调试法（小黄鸭）。求助其他人。倾听；提问；留意没有探究过的地方；了解接下来将会发生什么。解释问题会帮你理清思路</p></li><li><p>角色扮演</p></li><li><p>换换脑筋。潜意识帮助你</p></li><li><p>做些改变，什么改变都行。出去散个步最好</p></li><li><p>福尔摩斯原则：当你排除了一切不可能之后，无论它多么不可思议，它也一定是真相</p></li></ul><p>3.6 验证诊断</p><ul><li><p>向其他人解释你的诊断</p></li><li><p>检查源代码原始副本</p></li><li><p>多和其他人讨论，并假设你是错的</p></li></ul><p>4 修复缺陷</p><p>4.1 清楚障碍</p><p>从一个干净的代码树开始修改。</p><p>4.2 测试</p><ul><li><p>保证现有测试都可以通过</p></li><li><p>添加一个或者多个新的测试程序</p></li><li><p>修复 bug</p></li><li><p>证明修复起了作用</p></li><li><p>证明回归测试没有失败</p></li></ul><p>4.3 修复原因而非修复现象</p><p>理解问题的症结所在</p><p>4.4 重构</p><p>重构：改善代码设计而不改变其行为的过程。</p><ul><li><p>重构应该在有全面单测套件的安全网中才可以安全修改既有代码</p></li><li><p>重构或者修改功能，不能同时进行。 重构的同时决不能修改代码功能，同样也不能修复有缺陷的代码。(一次只做一件事)</p></li></ul><p>4.5 签入</p><p>一次逻辑修改只做一次签入。方便快速回滚和定位代码问题。</p><p>4.6 审查代码</p><p>5. 反思</p><p>5.1 这到底是怎么搞的</p><ul><li><p>如果缺陷仅仅发生在少数用户身上，你就要反思是否还有其他问题？</p></li><li><p>一个你以为会失败的 case，结果却成功了</p></li></ul><p>5.2 哪里除出了问题？</p><p>五个为什么？</p><ul><li><p>我们已经做到了么？</p></li><li><p>根本原因分析。责备没有用</p></li><li><p>需求是否正确，是否是模糊的，误解了</p></li><li><p>架构或者设计。有没有正确按照设计来做</p></li><li><p>测试。测试覆盖率足够么？</p></li><li><p>构造</p></li></ul><p>5.3 它不会再发生了</p><ul><li><p>自动验证，检查是否存在问题</p></li><li><p>和同事交流</p></li><li><p>重构代码避免被不正确使用</p></li><li><p>过程。检查工作过程</p></li></ul><p>5.4 关闭循环</p><p>编码规范；测试规范；文档规范；报告/跟踪过程；设计指南；性能需求</p><p>6. 发现代码存在问题</p><p>6.1 缺陷追踪</p><ul><li><p>使用缺陷追踪系统。</p></li><li><p>缺陷报告。具体，明确，详细的。</p></li><li><p>环境和配置报告。自动收集环境和配置信息，不要指望用户</p></li></ul><p>6.2 与用户合作</p><ul><li><p>简化流程</p></li><li><p>自动化</p></li><li><p>提供多种选择</p></li><li><p>尽量简单</p></li><li><p>模板不要死板</p></li><li><p>尊重用户隐私</p></li></ul><p>有效的沟通：</p><ul><li><p>心智模式。从用户角度设想一下</p></li><li><p>和非技术人员沟通</p></li><li><p>发布缺陷数据库</p></li><li><p>隐私问题；提供反馈；拜访用户</p></li></ul><p>6.3 与支持人员协同工作</p><p>学会沟通；和 QA 搞好关系，以便在修复缺陷的过程中得到帮助。</p><p>7. 务实的零容忍策略</p><p>7.1 缺陷优先</p><p>早期修复缺陷是一个好的策略：</p><ul><li><p>可能发现缺陷的过程（比如测试、代码审查、用户使用等）要连续贯穿整个开发过程</p></li><li><p>缺陷修复优先于其他任何事情</p></li><li><p>质量底下具有传染性。</p></li><li><p>破窗理论。发现缺陷就立马解决，不要留破窗户</p></li></ul><p>7.2 调试的思维模式</p><p>既要完美，又要实用。接近零容忍，但是用务实的心态去实现。</p><p>7.3 自己来解决质量问题</p><p>面对大量bug 如何摆脱困境？</p><ul><li><p>没有灵丹妙药。</p></li><li><p>停止开发有缺陷的程序。阻止事情恶化。</p></li><li><p>从不干净的代码中分离干净代码</p></li><li><p>缺陷分类</p></li><li><p>缺陷闪电战。集中较短时间专门修复缺陷</p></li></ul><p>8 特殊案例</p><p>8.1 修复已经发布软件</p><p>集中精力减少风险。</p><p>8.2 向后兼容</p><p>将确定兼容问题加入到你的缺陷修复检查列表中</p><ul><li><p>提供迁移方法</p></li><li><p>实现一个兼容模式。比如 word 就是这么做的</p></li><li><p>提供预警。java api 升级</p></li><li><p>不修复。极少数情况是一个务实的方案</p></li></ul><p>8.3 并发</p><p>简单和控制</p><p>让并发软件中问题更少地发生不是一个可取修复办法。 修复并发缺陷时，避免实用 sleep 方法。</p><p>8.4 海森堡缺陷</p><p>观察者效应。尽量减少收集信息带来的副作用</p><p>8.5 性能缺陷</p><ul><li><p>寻找瓶颈。性能分析器。通过检查代码有时候预测瓶颈是不可靠的。</p></li><li><p>没有瓶颈呢？是否是资源耗尽；垃圾收集；缓存丢失等</p></li></ul><p>8.6 嵌入式软件</p><p>仿真器；硬件还是软件问题；</p><p>8.7 第三方软件缺陷</p><ul><li><p>不要太快去指责。<strong>首先怀疑你自己的代码</strong></p></li><li><p>报告别人代码中的缺陷。慎重自己直接修复</p></li><li><p>linux 法则：眼睛足够多，bug 无处藏</p></li><li><p>报告问题：检查文档；尽可能给出足够信息</p></li></ul><p>9. 理想的调试环境</p><p>9.1 自动化测试</p><ul><li><p>结果明确，通过还是失败</p></li><li><p>环境独立</p></li><li><p>所有测试可以独立运行</p></li><li><p>全面覆盖</p></li></ul><p>9.2 源程序控制</p><ul><li><p>合理使用代码分支</p></li><li><p>坚持分之单一层级</p></li><li><p>设计 CI 构建所有正在活跃的分之</p></li><li><p>小的修改更加容易理解，合并和撤销</p></li><li><p>不要一次合并多个分之</p></li></ul><p>9.3 自动构建</p><ul><li><p>自动化构建整个过程，从开始到完成。</p></li><li><p>持续集成</p></li><li><p>静态分析(lint工具)。不要依赖未定义行为；谨慎对待编辑器警告</p></li></ul><p>10. 让软件学会自己寻找缺陷</p><p>10.1 假设和断言</p><p>fail early，使用断言保护代码。</p><p>契约式编程：</p><ul><li><p>先决条件。不如参数不能是空</p></li><li><p>后置条件。调用之后保持的条件，比如一个 http addHeader() 方法调用之后 headers map 比原来多一个</p></li><li><p>不变量。方法调用之前它的先决条件被满足就始终为真的数据。</p></li></ul><p>支持开启和关闭断言功能。</p><p>软件在产品阶段应该是鲁棒的，在调试阶段应该是脆弱的。 断言是一个缺陷检测机制，不是一个错误处理机制。</p><p>10.2 调试版本</p><p>不要等待资源泄露表现出来，主动今早地检测它们。</p><p>11. 反模式</p><p>11.1 夸大优先级</p><p>质量差才是导致大量缺陷的原因。</p><ul><li><p>定期清理缺陷</p></li><li><p>控制优先级</p></li><li><p>不要使用数字表示优先级</p></li></ul><p>11.2 超级巨星</p><p>巨星效应会破坏团队。一开始匆忙实现看似非常高效率(所以被称为”巨星”），但是遗留了一堆棘手的烂摊子。</p><ul><li><p>确保完成就是完成，需要功能被测试过了，检查过了，记录文档了。</p></li><li><p>任务分解为小任务</p></li><li><p>自负自责。谁搞得 bug 谁负责修理它。（有时候你可能要考虑拍屁股走人了，比如一堆 c 艹的烂摊子？？？）</p></li></ul><p>11.3 维护团队</p><p>最终开发和维护都要由一个团队来完成，保持连续性。不要区分开发和维护团队。</p><p>11.4 救火模式</p><p>退一步，找出根本原因，再去解决问题</p><p>救火模式永远也不会修复任何质量问题。</p><p>11.5 重写</p><p>从心理学角度来看，开发新代码比重写旧的代码让人更加舒服。天生乐观会让我们低估了复制旧功能要付出的精力和时间。 避免彻头彻尾重写，增量式重写代码。</p><p>11.6 没有代码所有权</p><p>集体代码所有权（极限编程）</p><p>11.7 魔法</p><p>任何你不理解的事情都可能隐藏有缺陷。唯一的方法就是纪律，把你不理解的事物都当成缺陷。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-20 08:29:02</div>
                <div class="content">
                    <p>#reading/debugging  Effective Debugging 隨記</p><p></p><p>https://zwiley.github.io/mybook/debug/Effective_Debugging/</p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE2NzQwMTM</p><p></p><p>1 章 宏观策略</p><p>1条：通过事务追踪系统处理所有问题</p><p>开源的有 Bugzilla/Launch-pad/OTR/Redmine/Trace 等，或者 JIRA 这种专有系统。</p><p>2条：在网上确切地查询你遇到的问题，以寻求解决灵感</p><p>简单、自足而且正确的范例（SSCCE）。搜索的时候用双引号可以更加精确搜索。搜不到可以去 stackoverflow 提问。</p><p>3条：确保前置条件和后置条件都满足</p><ul><li><p>不应该为 null，却为 null 的值</p></li><li><p>数学函数的参数保证在定义域之内</p></li><li><p>对象， 结构体和数组内部细节</p></li><li><p>变量是否在范围之内</p></li><li><p>传递的数据结构是否正确，map 有没有包含预期的 key/val，链表是否可以正常遍历</p></li></ul><p>4条：从具体问题入手向上追查 bug，或从高层程序入手向下追查 bug</p><ul><li><p>程序崩溃。通常null/未初始化的值容易引发崩溃</p></li><li><p>程序冻结(freeze)：找出循环的终止条件和没有满足的原因</p></li><li><p>错误消息：grep 找到错误消息位置</p></li></ul><p>5条：在正常运作的系统和发生故障的系统之间寻找差别</p><p>影响因素：代码、输入、参数、环境变量、动态链接库</p><ul><li><p>二分搜索</p></li><li><p>日志对比，grep/diff/comm</p></li></ul><p>6条：使用软件自身调试机制</p><ul><li><p>很多命令有 debug 选项。比如 sh -x， mysql explain</p></li></ul><p>7条：试着多种工具构建软件，并放在不同环境执行</p><ul><li><p>用多种编译工具构建软件，不同平台执行</p></li><li><p>考虑用更高级的语言重新实现</p></li></ul><p>8条：工作焦点放在最重要问题上</p><p>高优先级的 bug：</p><ul><li><p>数据丢失</p></li><li><p>数据安全</p></li><li><p>服务可用性降低</p></li><li><p>使用安全</p></li><li><p>程序崩溃或者冻结(freeze)</p></li><li><p>代码质量</p></li></ul><p>低优先级：</p><ul><li><p>支持遗留系统</p></li><li><p>向后兼容</p></li><li><p>有临时解决方案的问题</p></li><li><p>很少用的特性</p></li></ul><p>2 章 通用的方法与做法</p><p>9 条：相信自己能把问题调试好</p><ul><li><p>确信问题是可以排查的</p></li><li><p>流出足够的调试时间</p></li><li><p>安排好环境不受干扰。进入心流</p></li><li><p>睡一觉</p></li><li><p>学习环境和工具想关知识</p></li><li><p>准备好健壮的最小测试用例</p></li><li><p>bug 重现自动化</p></li><li><p>脚本分析日志文件</p></li><li><p>了解 API 或语言特性的运作方式</p></li></ul><p>10 条：高效地重建程序中的问题</p><p>sscce: 短小的(short)，自足的(self-contained)，正确的(correct)，范例(example)</p><ul><li><p>准确重现</p></li><li><p>短小正确的范例</p></li><li><p>创建执行环境</p></li><li><p>用版本管理打上标记</p></li></ul><p>11 条：修改完代码后，要能尽快看到结果</p><p>12 条：将复杂的测试场景自动化</p><p>通过脚本语言执行复杂的测试用例</p><p>13 条：使自己尽可能多地观察到与调试有关的数据</p><ul><li><p>扩大日志显示区域</p></li></ul><p>14 条：考虑对软件进行更新</p><ul><li><p>更新后重新尝试你的代码，是否还会出错？</p></li><li><p>谨慎考虑第三方出问题的可能，你自己出问题的几率更高</p></li></ul><p>15 条：查看第三方组件源代码，了解其用法</p><p>16 条：使用专门的监测和测试设备</p><p>协议分析工具，比如 wireshark, tcpdump 等监测网络数据包</p><p>17 条：使故障更加突出</p><ul><li><p>迫使软件去执行可疑路径</p></li><li><p>提升某些效果的幅度，令其更加突出，以便于研究</p></li><li><p>对软件加压，暴露出负载下的状态</p></li><li><p>所有修改都要在版本管理下做</p></li></ul><p>18 条：从自己的桌面计算机上调试那些不太好用的系统</p><p>19 条：使调试任务自动化</p><p>20 条：开始调试之前与调试完毕之后把程序清理干净</p><ul><li><p>确保调试之前代码整洁</p></li><li><p>调试完毕，把临时改动还原回去，只把有用的代码提交上去（考虑单独用一个分支）</p></li></ul><p>21 条：把属于同一个类型的所有问题全部都修复好</p><ul><li><p>修复一个错误之后，搜索代码类似的地方是否有一样的问题需要修改</p></li></ul><p>3章：通用的技术和工具</p><p>22 条：用 unix 命令行工具对调试数据进行分析</p><p>获取–筛选–处理–汇总</p><ul><li><p>nm 查看目标文件，获取哪些文件调用了 exit 函数。&nbsp;nm -A *.o | grep 'U exit$'</p></li><li><p>tar/jar/ar 查看压缩包内容</p></li><li><p>cut 裁剪，sed 正则提取</p></li><li><p>大量文本使用 more/less</p></li><li><p>xargs 命令输入端</p></li></ul><p>23 条：掌握命令行工具的各种选项和习惯用法</p><ul><li><p>fgrep -lr 'Missing foo'&nbsp;搜索所有包含错误消息的文件</p></li><li><p>对标准错误重定向以便于分析 ( 2&gt;&amp;1 )</p></li><li><p>tail -f&nbsp;监控持续增加的日志文件</p></li></ul><p>24 条：用编辑器对调试程序时所需的数据进行浏览</p><ul><li><p>使用编辑器搜索来查找拼写有误的单词</p></li><li><p>编辑文本突出不同点</p></li><li><p>编辑日志让其更加易读</p></li></ul><p>25 条：优化工作环境</p><ul><li><p>配置工具以提升效率。 alias/editor</p></li><li><p>通过版本控制共享 配置文件 (dotfiles)</p></li></ul><p>26 条：用版本控制寻找 bug 发生的原因和经过</p><p>每一次修改都应该单独提交，而且要写上有意义的提交信息，如果有可能，还应该链接到对应的事务(比如 jira)上。</p><ul><li><p>git log somefile&nbsp;查看某个文件变化</p></li><li><p>git blame file</p></li><li><p>git rev-list --all | xargs git grep extinctMethodName&nbsp;在过去的版本中搜索指定字符串</p></li><li><p>git log v1.2.3..&nbsp;只看某一个版本后开始发生的变化</p></li><li><p>git rev-list -n 1 --before=2015-08-01 master&nbsp;获取该日期之前最后一次提交所对应的 SHA hash</p></li><li><p>git log --all --grep='Issue #1234'&nbsp;搜索与某个事务有关的提交</p></li><li><p>git show lcb634f6&nbsp;指定展示某个 hash 的有关修改</p></li><li><p>git diff v1.2.3..v1.3.2&nbsp;显示两个版本之间的变化</p></li><li><p>git checkout v1.1.0&nbsp;回退到某个版本</p></li></ul><p>二分查找并且锁定测试没有通过的版本</p><p>git bisect start V1.1.0 V1.2.3 git bisect run test.sh git reset</p><p>如果正在做某一件事情，然后突然要去解决另外一件事，可以把当前的变更先隐藏，处理完别的事情之后再恢复。</p><p>git stash save interrupted-to-work-on-V1234 git stash pop</p><ul><li><p>用 git 查看文件的修改记录，确定 bug 何时以何种方式引入</p></li><li><p>用 git 查看正在运行的版本和故障版本之间的区别</p></li></ul><p>27 条：用工具监测多个独立程序构成的系统</p><ul><li><p>主机健康。</p></li><li><p>cpu 内存 网络可达性 进程数量 登录用户数量 可以更新的软件 剩余磁盘容量 打开的文件描述符 网络和磁盘带宽 系统日志 安全性 远程访问</p></li><li><p>服务健康。</p></li><li><p>数据库 邮件服务器 应用程序服务器 缓存 网络连接 备份 队列 消息传递 软件授权过期 web 服务器和目录</p></li></ul><p>最好可以监测到：</p><ul><li><p>能否正确处理整个流程</p></li><li><p>应用程序各个部分是否正常</p></li><li><p>某些关键指标是否正常。响应延迟，队列堆积，活跃用户数，失败交易，发生的错误和异常报告</p></li></ul><p>Nagios 系统可以用来检测。</p><p>要点：</p><ul><li><p>基础设施检查机制，各个部分是否正常</p></li><li><p>使自己可以在故障发生的时候迅速得到通知</p></li><li><p>查阅故障记录，发现规律或许可以帮你找出问题原因</p></li></ul><p>4章：调试器的使用技巧</p><p>28 条：编译代码时把符号信息包含进来，以便于调试</p><p>发布的时候记得删掉这些信息。</p><ul><li><p>大多数 unix 编译器支持用 -g 选项加入调试信息</p></li><li><p>调整，禁用优化选项</p></li></ul><p>29 条：对代码进行单步调试</p><ul><li><p>通过单步调试查看语句执行顺序和状态</p></li><li><p>跳过和 bug 无关部分</p></li><li><p>设置断点缩小范围</p></li></ul><p>30 条：设置代码断点和数据断点</p><ul><li><p>通过断点缩减范围</p></li><li><p>先在上游设置断点，然后再给需要的代码设置断点</p></li><li><p>针对异常或者程序退出的子程序设置断点</p></li><li><p>可以在调试器里终止没有响应的程序</p></li><li><p>数据断点锁定意外值导致的 bug</p></li></ul><p>31 条：了解反向调试功能</p><ul><li><p>gdb 提供了 record reverse-next reverse-step</p></li><li><p>反向调试对性能影响很大</p></li></ul><p>32 条：查看例程之间的相互调用情况</p><ul><li><p>gbd frame n 切换第 n 帧，up 和 down 上下移动</p></li><li><p>如果栈信息比较乱，代码可能写得有问题</p></li></ul><p>33 条：查看变量和表达式的值，以寻找错误</p><ul><li><p>gdb 中叫做 pretty-printer</p></li><li><p>python ，引入 pprint 模块</p></li><li><p>python tutor 可视化执行过程</p></li></ul><p>34 条：了解如何把调试器连接到正在运行的进程</p><p># 先查找进程 pid ps -u apache gdb -p pid</p><p>链接到正在运行的进程之后可以打断其执行过程 (gdb:break)，还可以设置断点</p><p>35 条：了解 core dump 信息进行调试</p><p>unix 可以通过 kill-ABRT pid 发送 SIGABRT 信号，迫使其生成转储文件。终端里可以用&nbsp;ctrl-\&nbsp;组合键发送这个信号。</p><p>36 条：把调试工具设置好</p><ul><li><p>cgdb/ddd 图形界面调试工具。</p></li><li><p>gdbinit 文件</p></li><li><p>gdb 可以运行 make 命令</p></li></ul><p>37 条：学会查看汇编代码和原始内存</p><p>查看机器码错误</p><ul><li><p>不必要的类型转换</p></li><li><p>误解了操作符优先级</p></li><li><p>无意中使用重载之后的操作符</p></li><li><p>没有配对的括号</p></li><li><p>错误的数值类型</p></li><li><p>不当的多态例程</p></li></ul><p>gdb 执行&nbsp;display/i$pc&nbsp;显示反汇编之后的指令，然后可以用 stepi, nexti 单步调试。 info registers 查看寄存器的值， 通过&nbsp;display$r0&nbsp;或者&nbsp;display$eas&nbsp;持续显示某个寄存器。 使用&nbsp;x/10xb&amp;a&nbsp;字节为单位，用十六进制显示 a 中的 10 个元素。</p><ul><li><p>小端序(little-endian)，先保存最低有效位字节</p></li><li><p>大端序(big-endian，大端在前，也称为网络序)</p></li></ul><p>5章：编程技术</p><p>38 条：对可疑代码进行评审，并手工演练这些代码</p><p>遵守约定，比如用括号理清楚运算符优先级。使用静态检查工具</p><p>需要关注的错误:</p><ul><li><p>操作符优先级是否有误（尤其是位操作）</p></li><li><p>缺少必要的括号和 break 语句</p></li><li><p>多谢了分号</p></li><li><p>比较操作误写为赋值 (== vs =)</p></li><li><p>变量没有初始化，或是初始化为错误的值</p></li><li><p>循环中缺少必要语句</p></li><li><p>off-by-one 错误</p></li><li><p>类型转化错误</p></li><li><p>拼写错误</p></li><li><p>缺少必要方法</p></li><li><p>特定编程语言陷阱</p></li></ul><p>重点：</p><ul><li><p>检查代码常见错误</p></li><li><p>用铅笔手工执行代码，验证是否正确</p></li><li><p>通过画图解析复杂的数据结构</p></li></ul><p>39 条：审读代码和同事讨论</p><p>橡皮鸭技术(rubber duck technique)。 专业和礼貌的方式评审。</p><p>40 条：给软件增加调试机制</p><ul><li><p>根据变异选项是否进入调试模式</p></li><li><p>通过命令行选项决定是否进入调试模式</p></li><li><p>发送 signal</p></li><li><p>通过命令行打开调试模式</p></li></ul><p>41 条：添加日志(log)语句</p><p>关键例程的入口和出口、重要数据结构内容、状态的变化和用户操作的回应等，注意不要在生产环境启用</p><p>42 条：对软件进行单元测试</p><ul><li><p>通过单测检查可疑例程，发现其中错误</p></li><li><p>使用合适的单测框架</p></li></ul><p>43 条：用断言进行调试</p><p>从前置条件、不变条件、后置条件思考，设置断言验证</p><ul><li><p>开头断言，验证 cpu 架构属性</p></li><li><p>例程入口断言，验证参数类型，是否有效(null)而且合理</p></li><li><p>例程出口验证是否正确</p></li><li><p>复杂的方法设置断言，验证状态</p></li><li><p>断言不会出错的 api</p></li><li><p>验证资源是否正确加在</p></li><li><p>验证复杂表达式的值</p></li><li><p>switch 断言分支处理</p></li><li><p>断言数据结构的初始化是否正确</p></li></ul><p>44 条：改动受测程序，验证推想</p><ul><li><p>手工设定代码中的某些值，验证哪些取值是正确的，那些错误的</p></li><li><p>试着用其他的方式 替换 当前实现</p></li></ul><p>45 条：尽量缩小正确范例与错误代码之间的差距</p><ul><li><p>缩减你的代码使其与范例代码相符，或者逐渐修改范例代码，使其与你的代码相符，有利于找到错误原因</p></li></ul><p>46 条：简化可疑代码</p><ul><li><p>复杂的代码会增加调试工作量，可以临时简化，删除不必要的代码，使错误更加突出</p></li><li><p>大函数拆分成小部分，单独测试一部分</p></li><li><p>弃用某些复杂的算法、数据结构、程序逻辑。 精巧但是很复杂的代码，容易出 bug，对性能没有那么高要求的地方可以替换成简单的实现版本</p></li></ul><p>47 条：将可疑代码替换成另一种编程语言编写</p><ul><li><p>使用表达能力更强的语言改写难以修复的代码，减少可能出错的语句数量</p></li><li><p>移植代码到更好的编程环境，用更强大的调试工具解决</p></li><li><p>参照新代码修正旧代码</p></li></ul><p>48 条：改善可疑代码的可读性与结构</p><p>混乱糟糕的代码容易滋生 bug。</p><p>装饰性的调整，代码重构，bug 修复工作要分开，并且要分别提交。</p><p>《重构》</p><p>49 条：清除 bug 根源，而不是仅仅消除症状</p><ul><li><p>不要采用临时代码绕开程序表面症状，而是要查找 bug 深层原因并且修复</p></li><li><p>尽可能采用通用方式处理复杂情况，而不要只修复某些特例</p></li></ul><p>6.章 编译时的调试技术</p><p>50 条：对生成的代码进行检视</p><ul><li><p>查看自动生成的代码（字节码，汇编等），理解编译时和运行时问题</p></li><li><p>通过工具展示成容易阅读的形式</p></li></ul><p>51 条：使用静态程序分析工具</p><p>lint 工具。最好加入到构建流程中</p><ul><li><p>null 进行解引用</p></li><li><p>并发错误和竞争条件</p></li><li><p>拼写有误的变量名</p></li><li><p>下标越界</p></li><li><p>错误的条件、循环、case，还有不会执行到的代码</p></li><li><p>未处理异常</p></li><li><p>没有用到的变量和例程</p></li><li><p>数学错误</p></li><li><p>代码重复</p></li><li><p>未实现接口</p></li><li><p>资源泄露</p></li><li><p>安全漏洞</p></li><li><p>特定编程语言问题</p></li></ul><p>gcc -Wall</p><p>52 条：对项目进行配置，让程序以固定方式构建和运行</p><ul><li><p>gcc 随机选取符号名称</p></li><li><p>输入给编译器的文件顺序可能不同</p></li><li><p>软件中构建表示的时间戳会发生变化</p></li><li><p>哈希表或map 遍历后顺序不同。防止算法复杂度攻击</p></li><li><p>加密盐</p></li></ul><p>53 条：对调试所用的程序库和构建代码执行环境进行配置</p><ul><li><p>启用编译器所支持的运行时调试功能</p></li><li><p>构建过程中引入一些第三方库检查代码</p></li></ul><p>7章：运行时调试技术</p><p>54 条：通过构建测试用例寻找错误</p><ul><li><p>创建一个可靠并且最简单的测试用例</p></li><li><p>加入到回归测试防止重复犯错</p></li></ul><p>55 条：让软件遇到问题时及早退出</p><p>测试环境中，及早退出有利于发现问题</p><ul><li><p>添加并启动断言</p></li><li><p>配置程序库进行严格检查</p></li><li><p>unix shell 开启 -e 选项，让 shell 在错误时候(return !=0)终止</p></li></ul><p>56 条：检查日志文件</p><p>分析日志：</p><ul><li><p>gui 事件查看器</p></li><li><p>文本编辑器。比如 vim 可以用g/regular-ex-pression/d&nbsp;删除无关的日志</p></li><li><p>unix 工具过滤、汇总、筛选</p></li><li><p>ELK、Logstash、loggly、Splunk</p></li></ul><p>57 条：对系统和进程所执行的操作进行性能评测</p><ul><li><p>(unix)对于 cpu 来说，负载是否高于核心数量</p></li><li><p>内存，虚拟内存页面写入到磁盘的频率</p></li><li><p>网络 IO，丢包和重传。 iostat, netstat, nfsstat, vmstat 等工具</p></li><li><p>虚拟设备 IO，请求队列长度和操作延迟</p></li></ul><p>58 条：追踪程序的执行情况</p><p>ltrace(追踪对程序库调用)，strace, ktrace, truss 追踪对操作系统调用</p><p>Dtrace。dtrace -n 'syscall:::entry'</p><p>59 条：使用动态程序分析工具</p><p>Valgrind 内存检查</p><p>8章：调试多线程代码</p><p>60 条：通过事后调试分析死锁问题</p><ul><li><p>gdb</p></li></ul><p># get pid ps # kill pid kill -QUIT pid # gdb deadlock core &gt;(gdb) info threads &gt;(gdb) thread 2 &gt;(gdb) backtrace</p><ul><li><p>jdk jstack 排查 java 死锁</p></li></ul><p>61 条：捕获并且重放</p><ul><li><p>开启记录功能，反复运行直到重现</p></li><li><p>分析记录结果</p></li><li><p>程序放在调试器中运行，重放 bug</p></li><li><p>对程序该点的状态分析，找到错误原因</p></li></ul><p># 程序名 race gdb_record race (gdb) break main (gdb) continue (gdb) pin record on (gdb) continue (gdb) quit</p><p>可以用 replay 命令重放，程序按照和当初相同的顺序操作内存，也会表现出同样的错误行为。</p><p>replay pinball/log_0 gdb_replay pinball/log_0 ./race</p><p>62 条：用专门的工具探查死锁和竞争条件问题</p><ul><li><p>FindBugs:&nbsp;java -jar findbugs.jar -textui Counter.class</p></li><li><p>Intel Inspector</p></li><li><p>valgrind --tool=helgrind deadlock</p></li></ul><p>63 条：把不确定因素隔离出来，或将其移除</p><ul><li><p>行为不确定的代码和其他代码隔开</p></li><li><p>对这些代码适当的实现和配置，然行为变确定</p></li><li><p>移除法：用可以预测的实体替换掉难以预测的部分</p></li><li><p>创建 mock 对象</p></li></ul><p>64 条：检查资源争用情况，以解决伸缩性问题</p><p>用 profiling 工具探查引发竞争现象的原因，以解决多线程代码中与可伸缩性有关的问题。</p><ul><li><p>Oracle Java Flight Recorder</p></li><li><p>Inter VTune Amplifier</p></li></ul><p>65 条：用性能计数器寻找伪共享问题</p><p>伪共享(false sharing)问题。cpu 核心的同步协议（缓存一致性协议），保证各线程总是可以看到一致的内存数据。 每个线程最好操作不同的内存区域(栈变量)，不要干涉其他线程所操作的内存数据</p><p>cpu 性能计数器。</p><p>用 perf 统计程序的末级缓存(last-level cache，简称 LLC)未命中次数。如果对缓存一致性协议的触发次数比较多， LLC-loads 就会随之增大。</p><p>per stat --event=LLC-loads ./sum-seq</p><p>66 条：考虑用高级的抽象机制重写代码</p><p>GNU parallel</p><p>使用更加高级的并发原语、编程语言、工具、框架等重新实现有 bug 的并发代码。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-19 00:17:00</div>
                <div class="content">
                    <p>拉马克说拼命抻，使劲努力，不仅自己脖子会变长，后代的脖子也会变长。这里，行为与结果之间有一个明确的因果关系，怎么能叫预定论呢？</p><p></p><p>来自“顾衡问答|基因变异为什么不能增加物种多样性？ | 顾衡好书榜”</p><p></p><p>#得到</p><p>https://www.dedao.cn/share/trialReading?trialReadingId=5ONB01yk97jbRo6Xn4PX2bz03i31h3Rm0I91BVmv4z6Yjypz3Wdlag8DVZLEqJKA&type=65</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-18 22:31:46</div>
                <div class="content">
                    <p>#reading/legacy-code Effective Debugging 66 Specific Ways to Debug Software and Systems by Diomidis Spinellis</p><p></p><p>chapter 01 高階策略</p><p>作法 01 透過問題記錄系統處理所有問題</p><p>☛以問題記錄系統處理所有問題☛確保每個問題有精確簡短與完整的如何複製說明☛根據問題的優先順序與嚴重性分類與安排工作程序☛透過系統記錄你的進度</p><p>作法 02 以精確的關鍵字上網查詢問題的線索</p><p>☛以雙引號包圍錯誤訊息執行搜尋☛StackExchange網站群的答案很有幫助☛如果以上方式均無效，張貼你的問題或登錄一項問題</p><p>作法 03 確認滿足前後條件</p><p>☛仔細檢查程序的前置條件與後置條件</p><p>作法 04 從問題向上到錯誤或從程式的開始向下到錯誤</p><p>☛能夠清楚識別原因，例如當掉、凍結與有錯誤訊息時，從下向上進行☛難以識別原因，例如效能、安全性與可靠性時，從上至下進行</p><p>作法 05 找出新舊系統間的差異</p><p>☛比較正常的系統與有問題的系統以找出失敗的成因☛考慮所有會影響系統行為的元素：程式碼、輸入、呼叫參數、環境變數、服務與動態連結函式庫</p><p>作法 06 使用軟體的除錯設施</p><p>☛認識要除錯的軟體有提供什麼除錯設施並使用它們來調查</p><p>作法 07 建構與執行環境的多元化</p><p>☛多樣化的編譯與執行平台能夠提供很有價值的除錯洞見☛以高階語言的實作來改正複雜的演算法</p><p>作法 08 專注於最重要的問題</p><p>☛並非所有問題都值得解決☛解決低優先問題會佔用處理高優先問題的時間</p><p>chapter 02 通用方法與實踐</p><p>作法 09 讓自己準備好</p><p>☛相信問題可以找到並解決☛為除錯工作保留足夠時間☛排除干擾☛遇到困難睡一下☛不要放棄☛投資環境、工具與知識</p><p>作法 10 有效的重複產生問題</p><p>☛複製簡化除錯程序☛建構複製錯誤的完整小範例☛使用可複製執行環境的機制☛使用版本控制系統標示與讀取軟體的版本</p><p>作法 11 減少來回修改的時間</p><p>☛快速的來回可提升效率☛設置自動化建構與部署程序☛減少測試失敗所需的時間</p><p>作法 12 複雜測試場合的自動化</p><p>☛使用腳本語言將複雜測試案例的執行自動化</p><p>作法 13 展示你的除錯資料</p><p>☛視野中的大量資料可以讓你更專注並找出模式與關聯☛使用最大顯示區域☛列印出相關的靜態資料</p><p>作法 14 更新你的軟體</p><p>☛在更新過的環境測試有問題的系統☛不要期望太高☛考慮第三方軟體有問題的可能</p><p>作法 15 參考第三方原始碼</p><p>☛取得你所使用的第三方程式的原始碼☛檢視原始碼來探索第三方API與錯誤訊息☛連結除錯版函式庫☛沒有其他辦法時才修改第三方程式</p><p>作法 16 使用專用監控與程式設備</p><p>☛邏輯、通道或協定分析儀可幫料你找出硬體層級發生的問題☛土方法或許可以幫助你調查與硬體相關的問題☛以Wireshark與Ethernet集線器、交換器或命令列工具監控網路封包</p><p>作法 17 放大失敗的效應</p><p>☛強制執行有問題的路徑☛放大某些效應以突顯它們☛對你的軟體施加壓力以讓它脫離舒適圈☛在版本控制下執行修改</p><p>作法 18 從你的桌面對遠端系統除錯</p><p>☛設置裝置的模擬器以讓你使用你的工作站的螢幕與鍵盤進行除錯☛使用軟體在你的工作站上以原生工具對嵌入程式碼除錯☛對客戶的電腦安排遠端存取☛設置KVM over IP裝置對遠端伺服器除錯</p><p>作法 19 除錯任務自動化</p><p>☛將全面搜尋自動化；電腦的時間比你的時間便宜</p><p>作法 20 除錯前後的清理工作</p><p>☛進行除錯工作前要確保基本的程式整潔☛完成後要清理臨時的修改並保存有用的修改</p><p>作法 21 修理有問題類別的所有實例</p><p>☛改正一個問題後，找出並改正類似的問題且要採取步驟來確保未來不再發生</p><p>chapter 03 通用工具與技巧</p><p>作法 22 以 Unix 命令列工具分析除錯資料</p><p>☛使用可以取得、選取、處理與統計文字記錄的Unix命令來分析除錯資料☛以管道組合Unix命令可讓你快速的完成複雜的分析工作</p><p>作法 23 使用命令列工具選項</p><p>☛grep的各種選項可以幫助你縮小搜尋範圍☛將程式的標準錯誤重新導向以便進行分析☛使用tail -f監控會新增資料的日誌檔案</p><p>作法 24 以編輯器探索除錯資料</p><p>☛使用編輯器的搜尋功能找出打字錯誤☛編輯文字以突顯差異☛編輯日誌檔案以提升可讀性</p><p>作法 25 工作環境最佳化</p><p>☛適當的設定工具以提升你的生產力☛在主機間以版本控制系統共用環境設定</p><p>作法 26 以版本控制系統追獵錯誤的成因與歷史</p><p>☛以版本控制系統檢視檔案歷史可顯示問題是如何發生的☛使用版本控制系統檢視正確與失敗版本的軟體間的差異</p><p>作法 27 使用系統的獨立行程監控工具</p><p>☛設置監控設施來檢查組成服務的各個部分☛快速通知可讓你在系統處於失敗狀態時進行除錯☛使用歷史記錄來識別模式可幫助你找出問題的成因</p><p>chapter 04 除錯技巧</p><p>作法 28 使用符號除錯編譯的程式</p><p>☛設定建構以取得需要的除錯資訊☛關閉編譯器最佳化以讓產生的碼與要除錯的程式相符</p><p>作法 29 逐步執行程式</p><p>☛逐步執行程式以檢視執行序列與程式的狀態☛跨過不相關的部分以加速檢視☛設定中斷點以縮小範圍，重複執行並跨入關鍵程序</p><p>作法 30 使用程式與資料中斷點</p><p>☛以程式中斷點縮小程式範圍☛加入中斷點以略過不相關的執行☛中斷例外或結束程序以對異常終結除錯☛從除錯工具停止程式的執行來解決當機☛以資料中斷點找出變數異常的改變</p><p>作法 31 熟悉反向除錯</p><p>☛熟悉反向除錯</p><p>作法 32 沿著程序間的呼叫</p><p>☛檢視程式的堆疊以了解它的狀態☛搞亂的堆疊是程式的問題產生的</p><p>作法 33 檢視變數與表達式的值以找尋錯誤</p><p>☛檢查重要表達式的值☛設置連續顯示執行演算法時會變化的表達式☛透過其區域變數追蹤程序的邏輯☛使用資料視覺化設施零處理複雜的資料結構</p><p>作法 34 知道如何將除錯工具附在行程上</p><p>☛對執行中的行程可將除錯工具附上以進行除錯☛透過遠端除錯設施對資源受限裝置上的應用程式進行除錯</p><p>作法 35 認識如何使用核心傾印</p><p>☛取得並檢視當掉與凍結的應用程式的記憶體傾印來進行除錯☛設定當機報告系統以對客戶端的應用程式除錯</p><p>作法 36 調校你的除錯工具</p><p>☛使用圖形介面除錯工具☛設定gdb儲存歷史與使用你偏好的鍵盤組合☛將常用命令放在gdb腳本中☛在gdb中建構你的程式以維護你輸入的命令</p><p>作法 37 認識如何檢視組合語言程式碼與原始記憶體</p><p>☛想要確實了解程式的行為，檢視分解後的機械指令☛暫存器eax或r0可以告訴你函式的回傳值☛想要確實了解資料如何儲存，檢視它的內部表示方式</p><p>chapter 05 程式設計技巧</p><p>作法 38 審核與手動執行可疑程式碼</p><p>☛找尋程式中的常見錯誤☛手動執行程式以檢驗其正確性☛畫圖以處理複雜的資料結構☛以大張紙、白板與顏色解決複雜性☛操作實體物件來強化與問題的接觸</p><p>作法 39 與同僚一起檢視你的程式碼</p><p>☛對小鴨解釋你的程式☛實踐程式碼審查☛透過角色扮演對多方問題除錯</p><p>作法 40 加入除錯功能</p><p>☛對你的程式加上進入除錯模式的選項☛加上命令來操控程式的狀態、記錄它的操作、減少執行期複雜性、使用者介面捷徑與顯示複雜的資料結構☛加上命令列、網頁與序列介面來對嵌入裝置與伺服器除錯☛使用除錯模式命令來模擬外部失敗</p><p>作法 41 加入日誌記錄陳述</p><p>☛加入記錄陳述以設置受維護的除錯基礎建設☛使用記錄平台架構而不要重新發明輪子☛透過記錄平台架構設定要記錄的主題與細節</p><p>作法 42 使用單元測試</p><p>☛使用單元測試探索可疑的程序以找出缺陷☛使用單元測試平台、重構程式與適合測試、自動化測試工作以提升效率</p><p>作法 43 使用斷言</p><p>☛以斷言補足單元測試來更精確的找出問題的位置☛以斷言對複雜的演算法除，檢驗它的前置條件、後置條件與不變性☛以斷言說明你對程式的理解並測試你的猜測</p><p>作法 44 擾動程式以檢驗你的推論</p><p>☛手動設置程式中的值以識別正確與錯誤值☛如果找不到程式的正確說明，嘗試其它實作方式</p><p>作法 45 將可行與失敗程式間的差異最小化</p><p>☛要找出導致失敗的元素，逐步的修改程式以符合可行的範例或讓範例符合你的程式</p><p>作法 46 簡化可疑程式</p><p>☛選擇性的刪除大區塊程式以突顯問題☛拆解複雜的陳述或函式以個別的監控與測試它們的功能☛考慮以簡單的演算法取代複雜的有問題演算法</p><p>作法 47 以其他語言重寫可疑的程式</p><p>☛以更具表達性的語言重寫改不好的程式來減少有問題的陳述的數量☛將有問題的程式轉換到更好的程式設計環境以強化你的除錯工具☛替代方案可行時，採用它或使用它來修改原來的程式</p><p>作法 48 改善可疑程式碼的易讀性與結構</p><p>☛以一致的方式格式化程式以讓你以肉眼捕捉錯誤模式☛重構程式以顯露出隱藏在沒寫好或過度複雜的程式結構中的錯誤</p><p>作法 49 治本而非治標</p><p>☛絕對不要為錯誤的症狀寫程式：找出問題並加以改正☛可能的話，將複雜問題以通用方式解決而不要修改特殊狀況</p><p>chapter 06 編譯期技巧</p><p>作法 50 檢視產生的程式碼</p><p>☛檢視自動產生的程式碼可以認識原始碼中的編譯與執行期問題☛使用編譯器選項或特殊工具來取得可讀的自動產生程式碼</p><p>作法 51 使用靜態程式分析</p><p>☛專用的靜態分析工具比編譯器警告可識別更多潛在的錯誤☛設定編譯器來分析程式的錯誤☛在建構與整合循環中引入至少一個靜態分析工具</p><p>作法 52 設定決定性建構與執行</p><p>☛設定建構程序與軟體執行以做到可複製的執行</p><p>作法 53 設定使用除錯函式庫</p><p>☛使用你的環境中的編譯器與函式庫所提供的執行期除錯支援☛如果沒有可用的支援，考慮設定你的軟體使用有提供支援的第三方函式庫</p><p>chapter 07 執行期技巧</p><p>作法 54 建構測試案例以找出問題</p><p>☛建構可靠的測試案例的過程可讓你找到錯誤與其解決方案☛在軟體中嵌入測試案例作為單元或廻歸測試</p><p>作法 55 盡快失敗</p><p>☛除錯時，設定觸發機制讓你的程式一出現問題症狀就失敗</p><p>作法 56 檢視應用程式日誌檔案</p><p>☛從檢視日誌檔案開始調查失敗的應用程式☛提高應用程式的日誌層級以記錄失敗的原因☛設定與過濾日誌檔案以找出問題</p><p>作法 57 系統與行程操作的側寫</p><p>☛觀察CPU、I/O與記憶體使用率以及飽和度來分析效能問題☛以行程的CPU與記憶體使用狀況的側寫縮小與效能問題有關的程式的範圍</p><p>作法 58 追蹤程式執行</p><p>☛系統與函式庫呼叫追蹤能讓你監控程式的行為而無須存取它的原始碼☛學習如何使用Windows Performance Toolkit (Windows)、SystemTap (Linux)或DTrace (OS X、Solaris、FreeBSD)</p><p>作法 59 使用動態程式分析工具</p><p>☛使用動態程式分析工具來找出實際在程式中發生的問題</p><p>chapter 08 多執行緒程式除錯</p><p>作法 60 以剖析除錯分析死結</p><p>☛取得打死結程式的快照並找出等待資源的程式與執行緒以對死結除錯</p><p>作法 61 擷取與複製</p><p>☛擷取失敗執行、分析記錄、並從除錯工具重播擷取檔案以找出非決定性的並行錯誤</p><p>作法 62 以專用工具找出死結與競爭狀況</p><p>☛以靜態分析工具梳理多執行緒程式以找出潛在的同步化與上鎖錯誤☛在動態分析工具下執行多執行緒程式以找出API誤用、潛在死結與資料競爭</p><p>作法 63 隔離與移除不確定性</p><p>☛隔離並行程式與其餘部分。這樣能讓你對每個部分使用最合適的除錯工具與技巧☛建構測試與除錯組態讓模擬物件與其他技巧使得程式的行為可以預期。這可提供可重複的程式執行</p><p>作法 64 檢視競爭以調查可擴展性問題</p><p>☛以側寫工具檢視競爭來源來解決多執行緒程式的擴展性問題</p><p>作法 65 以效能監視器找出假共用</p><p>☛使用監控效能計數器的側寫工具來辨識與隔離假共用情況</p><p>作法 66 以高階抽象重寫程式</p><p>☛為避免並行性陷阱，考慮以高階、專用語言、程序、工具、架構或平台重新實作有問題的並行程式</p><p></p><p>https://www.tenlong.com.tw/products/9789864762514?list_name=srh</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-17 22:19:44</div>
                <div class="content">
                    <p>#reading/legacy-code 如何讀code? 參考code reading 書嗎？</p><p></p><p>1. Introduction.</p><p>2. Basic Programming Elements. </p><p>3. Advanced C Data Types</p><p>4. C Data Structures. </p><p>5. Advanced Control Flow. </p><p>6. Tackling Large Projects. </p><p>7. Coding Standards and Conventions. </p><p>8. Documentation. </p><p>9. Architecture.</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE1OTc1ODY</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-17 16:31:11</div>
                <div class="content">
                    <p>#reading/legacy-code 對程式碼的理解不足，無法做修改</p><p></p><p>I Don’t Understand the Code Well Enough to Change It</p><p></p><ol><li><p><strong>Notes/Sketching 做筆記做草圖</strong></p><ol><li><p>寫下看到覺得重要的名詞</p></li><li><p>發現名詞和名詞存在某種連系(relationship)，在它們之間畫一條線</p></li><li><p></p></li></ol></li><li><p><strong>清單標注 listing markups</strong></p><ol><li><p>職責分離 Separating Responsibilities</p></li><li><p>理解方法結構 Understanding Method Structure</p></li><li><p>Extract Methods - coupling count</p></li><li><p>Understand the Effects of a Chang</p></li></ol></li><li><p><strong>Scratch Refactoring 草稿式重構</strong></p></li><li><p><strong>Delete Unused Code</strong></p></li></ol><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-16 08:36:09</div>
                <div class="content">
                    <p>#reading/legacy-code 解依賴的兩個理由 two reasons to break dependencies</p><p></p><p>1. Sensing We break dependencies to sense when we can't access values our code computes.</p><p>Separation We break dependencies to separate when we can't even get a piece of code into a test harness to run.</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE0OTY3MzY</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-16 08:31:48</div>
                <div class="content">
                    <p>#reading/legacy-code 沒有編寫單元測試的系統，得要先解依賴而後才能夠將某個class放入測試用具中。</p><p></p><p><strong>reasons:</strong></p><ul><li><p>We might want to create an object of one class and ask it questions, but to create</p><p>it, we need objects of another class, and those objects need objects of another class, and so on. <strong>Eventually, you end up with nearly the whole system in a harness.</strong></p></li><li><p>In systems that weren't developed concurrently with<strong> unit tests,</strong> we often have to break dependencies to get classes into a test harness.</p></li><li><p><strong>linking time 很花時間 -&gt; 拖慢turnaround的一次執行時間</strong></p></li><li><p><strong>感知(sense)  待測class 對其它class造成的影響 </strong>Sometimes the class we want to test has effects on other classes, and our tests need to know about them. </p></li><li><p>Sometimes we can sense those effects through the interface of the other class. At other times, we can't. The only choice we have is to impersonate the other class so that we can sense the effects directly.</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-15 11:27:44</div>
                <div class="content">
                    <p>#project/jazz-redesign 用waf 工具來找出submoudle的相依關係</p><p></p><ul><li><p>How can I make a library dependency graph with waf?</p></li><li><p>gccdeps</p></li><li><p>waf 加上--zones=deps 能print dependency資訊 </p></li></ul><p>https://stackoverflow.com/questions/19959595/how-can-i-make-a-library-dependency-graph-with-waf</p><ul><li><p>替代方案 - 更改 deps_why.c 來print dependency資訊，這些資訊可以進一步parse 整理出每個source file 和其它moudle 的相依關系</p><p></p></li></ul><ul><li><p>关联自：https://flomoapp.com/mine/?memo_id=MTE0NDM3OTY</p></li><li><p>https://flomoapp.com/mine/?memo_id=MTEzMTQ0NjE</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-15 11:15:35</div>
                <div class="content">
                    <p>#project/jazz-redesign 整理submodules 的差異</p><p></p><p>git ls-tree -r HEAD | grep commit | cut -c 1-14 --complement</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTE0NDM3OTY</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-15 10:49:11</div>
                <div class="content">
                    <p>#project/jazz-redesign WBL dependency</p><p></p><ul><li><p>WBL/ephemeris 用到 WBL/core，再用到 WBL/http-utilities</p></li><li><p>WBL 一直冒出要修改的submodules</p></li><li><p>編譯速度很慢，是否有可能waf 一次只編一個submodule?</p></li></ul><p></p><p>what change https://flomoapp.com/mine/?memo_id=MTEzMTQ0NjE</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-14 15:28:20</div>
                <div class="content">
                    <p>#project/jazz-redesign </p><ol><li><p>waf 編譯速度是否有問題？</p></li><li><p>在等待編譯時，能做什麼事呢？</p></li><li><p>用python 來做C unit test?</p></li></ol>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-14 09:52:17</div>
                <div class="content">
                    <p>#reading/legacy-code  working with feedback</p><p></p><p>單元測試要執行的快，執行的不快就不是單元測試。</p><p></p><p>大型測試的問題：</p><ul><li><p>不易定位錯誤 Error localization As tests get further from what they test, it is harder to determine what a test failure means. Often it takes considerable work to pinpoint the source of a test failure. You have to look at the test inputs, look at the failure, and determine where along the path from inputs to outputs the failure occurred. Yes, we have to do that for unit tests also, but often the work is trivial.</p></li><li><p>執行時間太長Execution time Larger tests tend to take longer to execute. This tends to make test runs rather frustrating. Tests that take too long to run end up not being run.</p></li><li><p>不知道涵蓋到那些 Coverage It is hard to see the connection between a piece of code and the values that exercise it. We can usually find out whether a piece of code is exercised by a test using coverage tools, but when we add new code, we might have to do considerable work to create high-level tests that exercise the new code.</p></li></ul><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTEyNDQ5NDQ</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 17:00:27</div>
                <div class="content">
                    <p>#reading/legacy-code  Part II 修改程式碼的技術</p><p></p><ul><li><p>Chapter 6 時間緊迫，但必須修改 6.1 新生方法 6.2 新生類別 6.3 外覆方法 6.4 外覆類別 6.5 小結</p></li><li><p>Chapter 7 漫長的修改 7.1 理解程式碼 7.2 時滯 7.3 解依賴 7.4 小結</p></li><li><p>Chapter 8 添加特性 8.1 測試驅動開發 8.2 差異式程式設計 8.3 小結</p></li><li><p>Chapter 9 無法將類別放入測試控制工具之中 9.1 令人惱火的參數 9.2 隱藏依賴 9.3 構造塊 9.4 惱人的全域依賴 9.5 可怕的包含依賴 9.6 「洋蔥」參數 9.7 化名參數</p></li><li><p>Chapter 10 無法在測試控制工具中執行方法 10.1 隱藏的方法 10.2 「有益的」語言特性 10.3 無法探知的副作用</p></li><li><p>Chapter 11 修改時應當測試哪些方法 11.1 推測程式碼修改所產生的影響 11.2 前向推測 11.3 影響的傳播 11.4 進行影響推測的工具 11.5 從影響分析當中學習 11.6 簡化影響結構示意圖</p></li><li><p>Chapter 12 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴 12.1 攔截點 12.2 透過匯點來判斷設計的好壞 12.3 匯點的陷阱</p></li><li><p>Chapter 13 修改時應該怎樣寫測試 13.1 特徵測試 13.2 刻畫類別 13.3 目標測試 13.4 編寫特徵測試的啟發式方法</p></li><li><p>Chapter 14 棘手的函式庫依賴問題</p></li><li><p>Chapter 15 到處都是API 呼叫</p></li><li><p>Chapter 16 對程式碼的理解不足 16.1 註記/草圖 16.2 清單標註 16.3 草稿式重構 16.4 刪除不用的程式碼</p></li><li><p>Chapter 17 程式毫無結構可言 17.1 講解系統的故事 17.2 Naked CRC 17.3 反省你們的交流或討論</p></li><li><p>Chapter 18 測試程式碼礙手礙腳 18.1 類別命名約定 18.2 測試程式碼放在哪裡</p></li><li><p>Chapter 19 對非物件導向的專案，如何安全地對它進行修改 19.1 一個簡單的案例 19.2 一個棘手的案例 19.3 添加新行為 19.4 利用物件導向的優勢 19.5 一切都是物件導向</p></li><li><p>Chapter 20 處理大類別 20.1 職責識別 20.2 其他技術 20.3 繼續前進 20.4 類別提取之後</p></li><li><p>Chapter 21 需要修改大量相同的程式碼 21.1 開始步驟</p></li><li><p>Chapter 22 要修改一個巨型方法，卻沒辦法為它編寫測試 22.1 巨型方法的種類 22.2 利用自動重構支援來對付巨型方法 22.3 手動重構的挑戰 22.4 策略</p></li><li><p>Chapter 23 降低修改的風險 23.1 超感編輯（Hyperaware Editing） 23.2 單一目標的編輯 23.3 簽章保持 23.4 依靠編譯器</p></li><li><p>Chapter 24 當你感到絕望時</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 16:51:17</div>
                <div class="content">
                    <p>#project/jazz-redesign check list</p><p></p><p>會參考Evonne 列在confluence上放WIFI/BLE/ANT的connectivity feature 檢查表，來看看host sw 是否有什麼self test或logs 能先查一輪沒有改壞東西。</p><p></p><p>risk changes: https://flomoapp.com/mine/?memo_id=MTEzMTQ0NjE</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 12:38:25</div>
                <div class="content">
                    <p>#project/jazz-redesign </p><p></p><ol><li><p>移除BTF支援，只用到ANT/BLE/WIFI</p><ol><li><p>不支援 device to device file transmission</p></li><li><p>no more dual pairing</p></li></ol></li><li><p>用sync 2.0 及BLE MTU/DLE 兩個模組來做&nbsp;file transmission to GCM</p></li></ol><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTEyNjMxOTY</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 12:35:49</div>
                <div class="content">
                    <p>#project/jazz-redesign Wireless Certification Testing Module (WCT)</p><p></p><p><strong>ANT/BLE/BT/Wifi</strong>&nbsp;testing</p><ul><li><p>Edge 530/580 看起來沒有做WCT integration</p></li><li><p>也不知道WCT做了什麼測試</p></li></ul><p></p><p>https://confluence.garmin.com/pages/viewpage.action?pageId=678337199</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 09:31:13</div>
                <div class="content">
                    <p>#reading/legacy-code make changes</p><p></p><p>When we need to make changes and preserve behavior</p><p></p><p>1. What changes do we have to make?</p><p>2. How will we know that we've done them correctly?</p><p>3. How will we know that we haven't broken anything?</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-13 09:12:30</div>
                <div class="content">
                    <p>#area/coding #project/jazz-redesign code review</p><p><strong>Books</strong></p><ul><li><p>Best Kept Secrets of Peer Code Review&nbsp;Older compilation of 10 essays on the practice of code reviews. Some repetition due to different authors covering the same territory.</p></li><li><p>Handbook of Walkthroughs, Inspections, and Technical Reviews&nbsp;Older book covering more formal walkthroughs but covers politics and group dynamics in review well.</p></li><li><p>Peer Reviews in Software: A Practical Guide&nbsp;A practical guide to formal code inspections as a code review practice.</p></li><li><p>Software Inspection: An Industry Best Practice&nbsp;Compendium of papers on code review practice.</p></li><li><p>Ultimate Guide to Code Reviews&nbsp;Codacy sponsored ebook of code review practices based on developer survey.</p></li><li><p>What to Look for in a Code Review&nbsp;JetBrains sponsored ebook of how to spot coding anti-patterns during review.</p></li></ul><p></p><p>src: https://github.com/joho/awesome-code-review</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-12 16:33:51</div>
                <div class="content">
                    <p>#project/jazz-redesign #reading/legacy-code The Legacy Code Change Algorithm</p><p>1. Identify change points.</p><p>2. Find test points.</p><p>3. Break dependencies.</p><p>4. Write tests.</p><p>5. Make changes and refactor.</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-12 11:14:40</div>
                <div class="content">
                    <p>#project/jazz-redesign</p><p></p><p>step 1 - pull up modules required for RS9116</p><p>step 2 - pass the tests of Jazz MT6630</p><p>step 3- bring in RS9116 (and sync 2.0) module</p><p>step 4 - pass the tests of Edge 1040</p><p>step 5 - Connectivity Feature Check List</p><p></p><p></p><ul><li><p>找到test cases (手動、自動、靜態分析、文件)</p></li><li><p>量測 test execution time</p></li><li><p>量測 test coverage</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-12 11:11:06</div>
                <div class="content">
                    <p>#project/mentalmodel  知道什麼地方會導致失敗，就要努力不要往那個地方去</p><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=MTEyMjg0Mjk</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 23:04:16</div>
                <div class="content">
                    <p>#reading/legacy-code 遺留代碼</p><p></p><p>legacy code 專指那些沒有撰寫相應測試的代碼。</p><p>我在現在工作處理過的專案，大都符合這個定義，如果這個測試是指unit testing，而不是integration或是system testing，那這些專案都是 legacy code。除非你很理解你在修改什麼，要不然每次修改都得帶著巨大的風險，是edit and pray的工作流程，而不是cover and modify。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 19:52:36</div>
                <div class="content">
                    <p>英文口說能力是我的高風險所在</p><p>关联自: https://flomoapp.com/mine/?memo_id=MTEyMjg0Mjk</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 19:51:03</div>
                <div class="content">
                    <p>#project/workflow 生死進退</p><p></p><p>开始创业，你期待的是增长，其实天天面对的都是生死进退。</p><p>你需要客观、冷静地看自己的真实处境。</p><p>如果你是在维持线上，真的非常要提醒你，要关注抗风险的系统设计。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 19:42:31</div>
                <div class="content">
                    <p>#project/workflow &nbsp;把过去靠拍脑袋碰运气的部分，分解为思考框架、决策模型</p><p></p><p>第一， 一张全景作战地图。它也是商业世界的全景图，草莽玩家、腰部玩家、头部玩家、顶级玩家，你能清楚看到各种玩家的位置、打法和能力限制，以及它们如何相互进攻。</p><p></p><p>第二，四个增长关卡。增长有四个重要的关卡：机会拿捏、模式取巧、组织扩容、战略借势。所有的企业，都在不同程度，被卡在某一个关卡里。</p><p>打破界限，突破关卡，即是增长。</p><p></p><p>第三，几十个真实案例。每个人看别人都是岁月静好，看自己都觉得悲催倒霉。</p><p>其实每个企业时时刻刻都在生死进退中挣扎，每个人的疼痛永不止息。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 15:29:11</div>
                <div class="content">
                    <p>#inbox &nbsp;十条亲密关系公约</p><p></p><ul><li><p>第一条：我承诺好好回应你，就像我也渴望得到你的回应一样。</p></li><li><p>第二条：我承诺把你看作不完美的人，而不是有问题的人。</p></li><li><p>第三条：我承诺如果委屈就会让你知道，哪怕我担心这些委屈会让我显得有些脆弱。</p></li><li><p>第四条：我承诺及时伸出修复关系的橄榄枝，也接受你伸过来的橄榄枝。</p></li><li><p>第五条：我承诺尊重你说“不”的权力，无论我多么希望靠近你。</p></li><li><p>第六条：我承诺不评论你的原生家庭，因为我知道那是你的来处。</p></li><li><p>第七条：我承诺不逼迫你改变，而是用我的改变带动你的改变。</p></li><li><p>第八条：我承诺不拉拢孩子来表达对你的不满，而只把问题留在你我之间。</p></li><li><p>第九条：我承诺不跟你争输赢，因为我知道，要么我们都输，要么我们都赢。</p></li><li><p>第十条：我承诺永远对你抱有期望，不管你会不会让我失望。</p></li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 13:52:45</div>
                <div class="content">
                    <p>#project/jazz-redesign 測試機台的數量</p><p></p><p>整機(011-)的部份:&nbsp;假設&nbsp;ANT/BT/BLE *1, WiFi *1, system *1,&nbsp;備用或是擺測試&nbsp;* 2</p><p>PCB(012-)的部分:&nbsp;至少也是拿個4-5片,&nbsp;假設要交叉驗證,&nbsp;或是有人可以來幫忙debug&nbsp;使用</p><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-11 11:15:41</div>
                <div class="content">
                    <p>#project/jazz-redesign #reading/legacy-code  感知和分離</p><p></p><p><strong>rapid turnaround -</strong></p><p>1. <strong>Sensing</strong>—We break dependencies to sense when we can’t access values our code computes.</p><p>2. <strong>Separation</strong>—We break dependencies to separate when we can’t even get a piece of code into a test harness to run.</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-09 08:30:53</div>
                <div class="content">
                    <p>#project/卡片盒 積累素材</p><p></p><p><strong>大量阅读、积累素材是写作的必经阶段。</strong>随着阅读量的提升，你能够看见自己的成长。具体而言，你可以积累什么样的素材？观点、论据、作者联系观点与论据的巧妙方式、各类好的隐喻。</p><p></p><p>http://blog.openmindclub.com/%E5%A4%A7%E5%B8%88%E7%B3%BB%E5%88%97/2019/12/18/YangZhiPing-Nabokov'sCards/</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-08 15:48:29</div>
                <div class="content">
                    <p>#project/almanack How to Get Rich (Without Getting Lucky)</p><p></p><p>https://www.hecaitou.info/2020/09/blog-post_22.html</p><p></p><p>1.&nbsp;Seek wealth, not money or status. Wealth is having assets that earn while you sleep. Money is how we transfer time and wealth. Status is your place in the social hierarchy.</p><p>去寻求财富，而非金钱或地位。财富就是你拥有资产，而资产在你睡觉的时候都还在为你赚钱；金钱是我们转换时间和财富的工具；身份是你在社会等级体系里所处的位置。</p><p>2.&nbsp;Understand that ethical wealth creation is possible. If you secretly despise wealth, it will elude you.</p><p>要明白一件事：一个人完全可以不靠坑蒙拐骗站着赚取财富。如果你在暗中鄙视财富，那么财富也会躲着你。</p><p>3.&nbsp;Ignore people playing status games. They gain status by attacking people playing wealth creation games.</p><p>别去理会那些热衷于玩身份游戏的人，他们通过攻击那些创造财富的人以获得自己的身份。</p><p>4.You’re not going to get rich renting out your time. You must own equity — a piece of a business — to gain your financial freedom.</p><p>你不会通过出租自己的时间而变得富有。你必须拥有产权，也就是生意的一部分，以此才能赢得个人财务自由。</p><p>5.You will get rich by giving society what it wants but does not yet know how to get. At scale.</p><p>提供社会大众想要但是他们还不知道如何获取的东西，你就会因此而致富。但有一点：你必须<strong>规模化</strong>地供应社会。</p><p>6.Pick an industry where you can play long term games with long term people.</p><p>选择一个你可以长期从事的产业，寻找一批可以一起长期共事的人。</p><p>7.The Internet has massively broadened the possible space of careers. Most people haven’t figured this out yet.</p><p>互联网极大拓展了一个人职业生涯的可能性。绝大多数人对此毫无认知。</p><p>8.Play iterated games. All the returns in life, whether in wealth, relationships, or knowledge, come from compound interest.</p><p>玩就玩复利游戏。无论是财富，人际关系或者是知识，所有你人生里获得的回报，都来自复利。</p><p>9.Pick business partners with high intelligence, energy, and, above all, integrity.</p><p>在选择商业合作伙伴的时候，选择那些高智商、精力旺盛的家伙，但在这一切之上，他应该是个<strong>正直诚实</strong>的人。</p><p>10.Don’t partner with cynics and pessimists. Their beliefs are self-fulfilling.</p><p>不要和愤世嫉俗者和悲观主义者合作，因为他们会任由坏事发生，以此证明他们的负面看法是正确的。</p><p>11.Learn to sell. Learn to build. If you can do both, you will be unstoppable.</p><p>学会如何销售，学会如何创建。如果你同时能做到这两件事，你的成功将无可阻挡。</p><p>12.Arm yourself with specific knowledge, accountability, and leverage.</p><p><strong>用独到知识，责任感和杠杆武装自己。</strong></p><p>13.Specific knowledge is knowledge that you cannot be trained for. If society can train you, it can train someone else, and replace you.</p><p><strong>独到知识</strong>是那种不可以通过培训而获得的知识。这是因为，如果这种知识可以经由培训而得，那么其他人同样也可以，并且以此取代你。</p><p>14.Specific knowledge is found by pursuing your genuine curiosity and passion rather than whatever is hot right now.</p><p>在真正的好奇心和热情驱使你前进的路上，你更有可能获得独到知识，而不是在追逐潮流热点的闻风起舞脚步里。</p><p>15.Building specific knowledge will feel like play to you but will look like work to others.</p><p>创建独到知识的过程对于你就像是在玩，而对于别人则像是工作。</p><p>16.When specific knowledge is taught, it’s through apprenticeships, not schools.</p><p>不能通过学校教育教会一个人独到知识，它只能通过<strong>学徒制</strong>口传身教。</p><p>17.Specific knowledge is often highly technical or creative. It cannot be outsourced or automated.</p><p>独到知识通常极富技术性和创造性，因此它不能被外包或自动实现。</p><p>18.Embrace accountability, and take business risks under your own name. Society will reward you with responsibility, equity, and leverage.</p><p>拥抱责任感，押上自己的声誉以承担商业风险。社会也会以责任，产权和杠杆作为回报。</p><p>19.The most accountable people have singular, public, and risky brands: Oprah, Trump, Kanye, Elon.</p><p>最具责任感的人都具有独一无二的、世人皆知的、敢于冒险的个性特征，如奥普拉、川普、坎耶、埃隆。</p><p>20.“Give me a lever long enough, and a place to stand, and I will move the earth.” — Archimedes</p><p>只要给我一根足够长的杠杆，一处可以立足的地方，我就能撬起地球。——阿基米德</p><p>21.Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media).</p><p>财富增长需要使用杠杆。商业杠杆有三个来源：1、资本；2、人力；3、复制起来边际成本为零的产品（如：代码和媒体）。</p><p>22.Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.</p><p>资本的意思就是钱。想要融资，那就运用你的独到知识，配合你责任感，展示出你良好的判断力。</p><p>23.Labor means people working for you. It’s the oldest and most fought-over form of leverage. Labor leverage will impress your parents, but don’t waste your life chasing it.</p><p>人力指的就是为你干活的人，它是最古老也是争夺最激烈的杠杆。人力杠杆会让你父母因为你手下有许多人为你工作而感到骄傲，但你不要浪费生命去追求这一点。</p><p>24.Capital and labor are permissioned leverage. Everyone is chasing capital, but someone has to give it to you. Everyone is trying to lead, but someone has to follow you.</p><p>资本和劳动力是需要征得许可才能使用的杠杆。每个人都在追逐资本，但总得有个什么人给你才行；每个人都想要领导其它人，但总得有什么人愿意跟着你才行。</p><p>25.Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep.</p><p>代码和媒体是无需要许可即可使用的杠杆。它们是新贵人群背后的杠杆，你可以通过自己创建的软件和媒体，在睡觉时仍然为你干活。</p><p>26.An army of robots is freely available — it’s just packed in data centers for heat and space efficiency. Use it.</p><p>一支机器人军团已经集结待命，只是为了节约空间和热效能，它们被打包放进数据中心。去用吧。</p><p>27.If you can’t code, write books and blogs, record videos and podcasts.</p><p>如果你不会编程，那你还可以写书和博客，或者做视频或者音频节目。</p><p>28.Leverage is a force multiplier for your judgement.</p><p>杠杆能够成倍地放大你的判断力（所产生的效能）。</p><p>29.Judgement requires experience, but can be built faster by learning foundational skills.</p><p>判断力需要经验，但它可以通过学习基本技能的方法更快速地建立起来。</p><p>30.There is no skill called “business.” Avoid business magazines and business classes.</p><p>并不存在一种叫做“商业”的能力。尽量避开商业杂志和商业课程。</p><p>31.Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.</p><p>去学习微观经济学、博弈论、心理学、说服术、伦理学、数学和计算机科学。</p><p></p><p>32.Reading is faster than listening. Doing is faster than watching.</p><p>读比听快，做比看快。</p><p>33.You should be too busy to “do coffee,” while still keeping an uncluttered calendar.</p><p>你应该忙得没有社交的时间才对，与此同时你应该始终保证日程安排井井有条。</p><p>34.Set and enforce an aspirational personal hourly rate. If fixing a problem will save less than your hourly rate, ignore it. If outsourcing a task will cost less than your hourly rate, outsource it.</p><p>你应该为自己设定一个有抱负的个人时薪数，并且坚持执行。如果解决一个问题所能节省下来的成本低于你的个人时薪，那就忽略这个问题好了；如果一项任务的外包成本低于你的个人时薪，就把它外包出去。</p><p>35.Work as hard as you can. Even though who you work with and what you work on are more important than how hard you work.</p><p>尽管你跟谁一起工作、做什么工作，要远比你的努力程度更加重要。但还是要倾尽全力去工作。</p><p>36.Become the best in the world at what you do. Keep redefining what you do until this is true.</p><p>你所做的事情，要努力做到世界最好。不断重新定义你在做什么，直到真的做到世界最好。</p><p>37.There are no get rich quick schemes. That’s just someone else getting rich off you.</p><p>这个世界上并没有快速赚钱致富的方法，如果你想要找寻这种方法，那它只会让别人从你身上赚钱致富。</p><p>38.Apply specific knowledge, with leverage, and eventually you will get what you deserve.</p><p>运用你的独到知识，配合上杠杆，最终你会得到你应该得到的东西。</p><p>39.When you’re finally wealthy, you’ll realize that it wasn’t what you were seeking in the first place. But that’s for another day.</p><p>终有一天当你变得富有，你会发现那一切并不是你最开始想要的东西。但是那就是另外一回事了。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-08 15:43:45</div>
                <div class="content">
                    <p>#project/almanack  BUILDING JUDGMENT</p><p>Judgment 94</p><p>How to Think Clearly 95</p><p>Shed Your Identity to See Reality 101</p><p>Learn the Skills of Decision-Making 103</p><p>Collect Mental Models 106</p><p>Learn to Love to Read 114</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-08 12:57:29</div>
                <div class="content">
                    <p>#project/almanack 积累财富</p><ul><li><p>理解财富是如何创造的 14</p></li><li><p>寻找和建立专门的知识 22</p></li><li><p>与长期的人玩长期的游戏 27</p></li><li><p>承担责任 30</p></li><li><p>建立或购买企业的股权 32</p></li><li><p>找到一个杠杆的位置 35</p></li><li><p>判决后获得报酬 . 46</p></li><li><p>优先和重点 48</p></li><li><p>寻找感觉像游戏的工作 55</p></li><li><p>如何获得幸运 60</p></li><li><p>耐心点 65</p></li></ul><p></p><p>BUILDING WEALTH 29</p><p>Understand How Wealth Is Created 30</p><p>Find and Build Specific Knowledge 40</p><p>Play Long-Term Games with Long-Term People 46</p><p>Take on Accountability 50</p><p>Build or Buy Equity in a Business 53</p><p>Find a Position of Leverage 55</p><p>Get Paid for Your Judgment 67</p><p>Prioritize and Focus 69</p><p>Find Work That Feels Like Play 76</p><p>How to Get Lucky 82</p><p>Be Patient 87</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-08 10:12:49</div>
                <div class="content">
                    <p>#project/workflow 產品領導者</p><p></p><p>产品团队的职责其实可以归纳为两条，一是“build the right product”，二是“build the product right”。前者是方向问题，属于产品探索的范畴；后者是方法问题，属于产品交付的范畴。这两项职责大相径庭，通常情况下很难由同一支团队完成。在卡根看来，要求普通团队同时承担探索和交付工作未免强人所难，效果往往也不尽如人意；而自主型团队权、才、利兼而有之，因此可以打造出既有价值和可用性、又具备技术可行性和商业可行性的产品。</p><p></p><p>src: empowered 2 书名：启示录2：打造优秀的产品团队</p><p>作者：【美】马蒂·卡根；克里斯·琼斯</p><p></p><p>本书面向产品领导者和有志于成为产品领导者的人士，尤其是产品经理、产品设计师与开发人员的上司。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-07 23:18:04</div>
                <div class="content">
                    <p>#project/workflow 年終工作總結 不是年終，不是工作，不是總結</p><p></p><ol><li><p>不是年終，不是對過去的複盤，應該把它當作一次面向未來的競聘。</p></li><li><p>不是工作，重點不是要說你幹了什麼，而是要呈現你的變化，你這一年能力有什麼成長</p></li><li><p>不是總結, 可以做為跟領導的一次年終面試，是在回答那些他期待知道的問題。</p></li></ol><p></p><p>重點放在自已的能力證明上。</p><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-07 23:14:03</div>
                <div class="content">
                    <p>#project/workflow 使用清單</p><p></p><ol><li><p>使用清單，避免無能之錯</p></li><li><p>使用清單，建立SOP</p></li><li><p>使用清單,  建立問題解決方案</p></li></ol><p></p><p>关联自：https://flomoapp.com/mine/?memo_id=ODU4NTAwNA</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-06 15:56:08</div>
                <div class="content">
                    <p>#project/leetcode study plan - Dynamic Programming</p><p></p><p>https://leetcode.com/study-plan/dynamic-programming/ </p><p></p><p><strong>Dynamic Programming I</strong></p><p>Avg. 2~3 problems / day&nbsp;｜&nbsp;21 days</p><p>Easy <strong>9</strong></p><p>Medium <strong>35</strong></p><p>Hard <strong>2</strong></p><p></p><p><strong>Dynamic Programming II</strong></p><p>Avg. 2~3 problems / day&nbsp;｜&nbsp;21 days</p><p>Easy <strong>5</strong></p><p>Medium <strong>42</strong></p><p>Hard <strong>2</strong></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-06 15:55:16</div>
                <div class="content">
                    <p>#project/leetcode study plan - data structure</p><p></p><p>https://leetcode.com/study-plan/data-structure/</p><p></p><p>Data Structure I</p><p>Avg. 2~3 problems / day&nbsp;｜&nbsp;14 days</p><p>Easy <strong>28</strong></p><p>Medium <strong>5</strong></p><p>Hard <strong>0</strong></p><p></p><p><strong>Data Structure II</strong></p><p>Avg. 2~3 problems / day&nbsp;｜&nbsp;21 days</p><p>Easy <strong>11</strong></p><p>Medium <strong>37</strong></p><p>Hard <strong>2</strong></p><p></p><p><strong>Data Structure III</strong></p><p>Avg. 2~3 problems / day&nbsp;｜&nbsp;28 days</p><p>Easy <strong>5</strong></p><p>Medium <strong>37</strong></p><p>Hard <strong>18</strong></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-06 15:54:21</div>
                <div class="content">
                    <p>#project/leetcode  Algorithm</p><ul><li><p>* 可以先讓自已專注 Leetcode 的study plan中的algorithm，每天解個2-3題的進度，總共要62天，約2個月的時間。</p></li><li><p>algorithm 1 - 31 tasks/14days</p></li><li><p>algorithm 2 - 47 tasks/21days</p></li><li><p>algorithm 3 - 60 tasks/27days</p></li><li><p>src: https://leetcode.com/study-plan/algorithm/?progress=p0njfo6</p><p></p></li></ul><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-05 10:32:55</div>
                <div class="content">
                    <p>#project/workflow reinventing you 重塑你自已</p><p></p><p>關鍵步驟1：確定目標</p><p>關鍵步驟2：善用差異性</p><p>關鍵步驟3：發展立論</p><p>關鍵步驟4：重新自我介紹</p><p>關鍵步驟5：證明你的價值</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-02 08:26:10</div>
                <div class="content">
                    <p>#project/cs MOSFET 金屬氧化物半導體場效電晶體</p><p></p><p><strong>金屬氧化物半導體場效電晶體</strong>（簡稱：<strong>金氧半場效電晶體</strong>；英語：<strong>Metal-Oxide-Semiconductor Field-Effect Transistor</strong>，縮寫：<strong>MOSFET</strong>），是一種可以廣泛使用在類比電路與數位電路的場效電晶體。</p><p>金屬氧化物半導體場效電晶體依照其通道極性的不同，可分為電子占多數的N通道型與電洞占多數的P通道型，通常被稱為N型金氧半場效電晶體（NMOSFET）與P型金氧半場效電晶體（PMOSFET）。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-01 21:01:01</div>
                <div class="content">
                    <p>#project/卡片盒 如何理解一個概念</p><p>https://mp.weixin.qq.com/s/PcvVYxerhO4DAlrnDNzsOQ</p><p></p><ul><li><p>從知道到做到</p></li><li><p>知道、理解、使用、精通</p></li></ul><p></p><ul><li><p>know can do 知道做到</p><ul><li><p>怎样避免知识过量。</p></li><li><p>怎样通过适量的学习掌握最多的信息。</p></li><li><p>怎样调整大脑的过滤系统，使自己能够获得比之前多100倍的知识。</p></li><li><p>怎样用已被大家接受的思想来点燃创造力与智慧之光。</p></li><li><p>令人欢欣鼓舞的发展怎样引发知识的增长与行动的加快。</p></li><li><p>人们怎样通过不间断的知识重温与坚持不懈的探索，最终获得对知识的理解与掌握。</p></li><li><p>为什么掌握恰当的学习方法至关重要呢？</p></li></ul></li></ul>
                </div>
                <div class="files">
                                        <img src="file/2021-12-06/180914/50407cf0cca534591934fedfcf3435cf.png" />
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2021-12-01 12:45:14</div>
                <div class="content">
                    <p>#project/workflow 即對於專業創意人員來說，花錢升級工作空間的美感不僅僅是一種表達練習，而且可能是你做過的最好的商業投資之一</p><p></p><p>sr: https://www.calnewport.com/blog/2021/11/23/the-forgotten-tale-of-george-lucass-writing-tower/</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                    </div>
    </body>
</html>