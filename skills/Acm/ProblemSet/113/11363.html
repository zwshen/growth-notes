
<!--Converted with LaTeX2HTML 2K.1beta (1.48)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Cuckoo Hashing</TITLE>
<META NAME="description" CONTENT="Cuckoo Hashing">
<META NAME="keywords" CONTENT="htmlatex">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="htmlatex.css">

</HEAD>

<BODY LANG="EN" BGCOLOR=#FFFFFF>

<H1><BR CLEAR=ALL><CENTER><TABLE BGCOLOR=#0000ff><TR><TD><B><FONT SIZE=5 COLOR=#FFff00>&nbsp;<A NAME="SECTION0001000000000000000000">
B: Cuckoo Hashing</A>&nbsp;</FONT></B></TABLE></CENTER>
</H1>

<P>
One of the most fundamental data structure problems is the dictionary problem: given a set <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark> of words you want to be able to quickly determine if any given query string <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark> is present in the dictionary <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark> or not. Hashing is a well-known solution for the problem. The idea is to create a function <SPAN CLASS="MATH"><I>h</I></SPAN>
<tex2html_verbatim_mark> :  <!-- MATH
 $\sum ^{\ast} \rightarrow [0..n - 1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img1.png"
 ALT="$ \sum^{{\ast}}_{}$"> <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="11363img2.png"
 ALT="$ \rightarrow$"> [0..<I>n</I> - 1]</SPAN>
<tex2html_verbatim_mark> from all strings to the integer range <!-- MATH
 $0, 1, \ldots, n - 1$
 -->
<SPAN CLASS="MATH">0, 1,..., <I>n</I> - 1</SPAN>
<tex2html_verbatim_mark>, i.e. you describe a fast deterministic program which takes a string as input and outputs an integer between 0 and <SPAN CLASS="MATH"><I>n</I> - 1</SPAN>
<tex2html_verbatim_mark>. Next you allocate an empty hash table <SPAN CLASS="MATH"><I>T</I></SPAN>
<tex2html_verbatim_mark> of size <SPAN CLASS="MATH"><I>n</I></SPAN>
<tex2html_verbatim_mark> and for each word <SPAN CLASS="MATH"><I>w</I></SPAN>
<tex2html_verbatim_mark> in <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark>, you set <!-- MATH
 $T [h(w)] = w$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I>(<I>w</I>)] = <I>w</I></SPAN>
<tex2html_verbatim_mark>. Thus, given a query string <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark>, you only need to calculate <SPAN CLASS="MATH"><I>h</I>(<I>q</I>)</SPAN>
<tex2html_verbatim_mark> and see if <SPAN CLASS="MATH"><I>T</I>[<I>h</I>(<I>q</I>)]</SPAN>
<tex2html_verbatim_mark> equals <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark>, to determine if <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark> is in the dictionary. Seems simple enough, but aren't we forgetting something? Of course, what if two words in <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark> map to the same location in the table? This phenomenon, called collision, happens fairly often (remember the Birthday paradox: in a class of 24 pupils there is more than 50<SPAN CLASS="MATH">%</SPAN>
<tex2html_verbatim_mark> chance that two of them share birthday). On average you will only be able to put roughly  <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img3.png"
 ALT="$ \sqrt{{n}}$"></SPAN>
<tex2html_verbatim_mark>-sized dictionaries into the table without getting collisions, quite poor space usage! 

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $\epsfbox{p11363.eps}$
 -->
<IMG
 WIDTH="228" HEIGHT="171" ALIGN="right" BORDER="0"
 SRC="p11363.png"
 ALT="\epsfbox{p11363.eps}">
<tex2html_verbatim_mark>
</DIV>

<P>
A stronger variant is Cuckoo Hashing (<EM>Cuckoo Hashing was suggested by the danes R. Pagh and F. F. R&#246;dler in 2001</EM>). The idea is to use two hash functions <SPAN CLASS="MATH"><I>h</I><SUB>1</SUB></SPAN>
<tex2html_verbatim_mark> and <SPAN CLASS="MATH"><I>h</I><SUB>2</SUB></SPAN>
<tex2html_verbatim_mark>. Thus each string maps to two positions in the table. A query string <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark> is now handled as follows: you compute both <SPAN CLASS="MATH"><I>h</I><SUB>1</SUB>(<I>q</I>)</SPAN>
<tex2html_verbatim_mark> and <SPAN CLASS="MATH"><I>h</I><SUB>2</SUB>(<I>q</I>)</SPAN>
<tex2html_verbatim_mark>, and if <!-- MATH
 $T [h_{1} (q)] = q$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>1</SUB>(<I>q</I>)] = <I>q</I></SPAN>
<tex2html_verbatim_mark>, or <!-- MATH
 $T [h_{2} (q)] = q$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>2</SUB>(<I>q</I>)] = <I>q</I></SPAN>
<tex2html_verbatim_mark>, you conclude that <SPAN CLASS="MATH"><I>q</I></SPAN>
<tex2html_verbatim_mark> is in <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark>. The name ``Cuckoo Hashing" stems from the process of creating the table. Initially you have an empty table. You iterate over the words <SPAN CLASS="MATH"><I>d</I></SPAN>
<tex2html_verbatim_mark> in <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark>, and insert them one by one. If <!-- MATH
 $T [h_{1} (d)]$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>1</SUB>(<I>d</I> )]</SPAN>
<tex2html_verbatim_mark> is free, you set <!-- MATH
 $T [h_{1} (d)] = d$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>1</SUB>(<I>d</I> )] = <I>d</I></SPAN>
<tex2html_verbatim_mark>. Otherwise if <!-- MATH
 $T [h_{2} (d)]$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>2</SUB>(<I>d</I> )]</SPAN>
<tex2html_verbatim_mark> is free, you set <!-- MATH
 $T [h_{2} (d)] = d$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>2</SUB>(<I>d</I> )] = <I>d</I></SPAN>
<tex2html_verbatim_mark>. If both are occupied however, just like the cuckoo with other birds' eggs, you evict the word <SPAN CLASS="MATH"><I>r</I></SPAN>
<tex2html_verbatim_mark> in <!-- MATH
 $T [h_{1} (d)]$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>1</SUB>(<I>d</I> )]</SPAN>
<tex2html_verbatim_mark> and set <!-- MATH
 $T [h_{1} (d)] = d$
 -->
<SPAN CLASS="MATH"><I>T</I>[<I>h</I><SUB>1</SUB>(<I>d</I> )] = <I>d</I></SPAN>
<tex2html_verbatim_mark>. Next you put <SPAN CLASS="MATH"><I>r</I></SPAN>
<tex2html_verbatim_mark> back into the table in its alternative place (and if that entry was already occupied you evict that word and move it to its alternative place, and so on). Of course, we may end up in an infinite loop here, in which case we need to rebuild the table with other choices of hash functions. The good news is that this will not happen with great probability even if <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark> contains up to <SPAN CLASS="MATH"><I>n</I>/2</SPAN>
<tex2html_verbatim_mark> words!

<P>

<H2><FONT size=4 COLOR=#ff0000><A NAME="SECTION0001001000000000000000">
Input</A>&nbsp;</FONT>
</H2>

<P>
On the first line of input is a single positive integer <!-- MATH
 $1 \le t \le 50$
 -->
<SPAN CLASS="MATH">1<IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img5.png"
 ALT="$ \le$"><I>t</I><IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img5.png"
 ALT="$ \le$">50</SPAN>
<tex2html_verbatim_mark> specifying the number of test cases to follow. Each test case begins with two positive integers <!-- MATH
 $1 \le m \le n \le 10000$
 -->
<SPAN CLASS="MATH">1<IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img5.png"
 ALT="$ \le$"><I>m</I><IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img5.png"
 ALT="$ \le$"><I>n</I><IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="11363img5.png"
 ALT="$ \le$">10000</SPAN>
<tex2html_verbatim_mark> on a line of itself, <SPAN CLASS="MATH"><I>m</I></SPAN>
<tex2html_verbatim_mark> telling the number of words in the dictionary and <SPAN CLASS="MATH"><I>n</I></SPAN>
<tex2html_verbatim_mark> the size of the hash table in the test case. Next follow <SPAN CLASS="MATH"><I>m</I></SPAN>
<tex2html_verbatim_mark> lines of which the <SPAN CLASS="MATH"><I>i</I></SPAN>
<tex2html_verbatim_mark>:th describes the <SPAN CLASS="MATH"><I>i</I></SPAN>
<tex2html_verbatim_mark>:th word <SPAN CLASS="MATH"><I>d</I><SUB>i</SUB></SPAN>
<tex2html_verbatim_mark> in the dictionary <SPAN CLASS="MATH"><I>D</I></SPAN>
<tex2html_verbatim_mark> by two non-negative integers <!-- MATH
 $h_{1} (d_{i})$
 -->
<SPAN CLASS="MATH"><I>h</I><SUB>1</SUB>(<I>d</I><SUB>i</SUB>)</SPAN>
<tex2html_verbatim_mark> and <!-- MATH
 $h_{2} (d_{i})$
 -->
<SPAN CLASS="MATH"><I>h</I><SUB>2</SUB>(<I>d</I><SUB>i</SUB>)</SPAN>
<tex2html_verbatim_mark> less than <SPAN CLASS="MATH"><I>n</I></SPAN>
<tex2html_verbatim_mark> giving the two hash function values of the word <SPAN CLASS="MATH"><I>d</I><SUB>i</SUB></SPAN>
<tex2html_verbatim_mark>. The two values may be identical.

<P>

<H2><FONT size=4 COLOR=#ff0000><A NAME="SECTION0001002000000000000000">
Output</A>&nbsp;</FONT>
</H2>

<P>
For each test case there should be exactly one line of output either containing the string ``<TT>successful hashing</TT>" if it is possible to insert all words in the given order into the table, or the string ``<TT>rehash necessary</TT>" if it is impossible.

<P>

<H2><FONT size=4 COLOR=#ff0000><A NAME="SECTION0001003000000000000000">
Sample Input</A>&nbsp;</FONT>
</H2>

<P>
<PRE>
2 
3 3
0 1
1 2
2 0
5 6
2 3
3 1
1 2
5 1
2 5
</PRE>

<P>

<H2><FONT size=4 COLOR=#ff0000><A NAME="SECTION0001004000000000000000">
Sample Output</A>&nbsp;</FONT>
</H2>

<P>
<PRE>
successful hashing 
rehash necessary
</PRE>

<P>


<P>
<BR><HR>

</BODY>
</HTML>
</HTML>
