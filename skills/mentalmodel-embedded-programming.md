# Skill: Embedded Programming

## Readings List
* Embedded Programming
  * 嵌入式系統開發之道
  * The Firmware Handbook https://www.amazon.com/Firmware-Handbook-Embedded-Technology/dp/075067606X
  * Embedded Software know it all
  * Embedded Hardware know it all
* Code Complete 2
  * Applying UML and Patterns 3rd Edition
  * Steve McConnell - Rapid Development - Taming Wild Software Schedules
  * Software Requirements 3
* Structure And Interpretation Of Computer Programs
* Operating Systems - Three Easy Pieces (OSTEP)
* 電子電路
  * 微電子學 Vol 1
  * The art of electronics (3rd) https://www.amazon.com/Art-Electronics-Paul-Horowitz/dp/0521809266
  * Fundamentals of Electric Circuits

## meta learning

## Code Complete - teaches us the importance of software construction, and how to do it right.

* What Is Software Construction
  * What Is Software Construction?
  * Why Is Software Construction Important?
  * How to Read This Book

* Metaphors for a Richer Understanding of Software Development
  * The Importance of Metaphors
  * How to Use Software Metaphors
  * Common Software Metaphors
  * Combining Metaphors

* Measure Twice, Cut Once: Upstream Prerequisites
  * Importance of Prerequisites
  * Determine the Kind of Software You're Working On
  * Problem-Definition Prerequisite
  * Requirements Prerequisite
  * Architecture Prerequisite
  * Amount of Time to Spend on Upstream Prerequisites

* Key Construction Decisions
  * Choice of Programming Language
  * Programming Conventions
  * Your Location on the Technology Wave
  * Selection of Major Construction Practices

* Design in Construction
  * Design Challenges
  * Key Design Concepts
  * Design Building Blocks: Heuristics
  * Design Practices
  * Comments on Popular Methodologies

* Working Classes
  * Class Foundations: Abstract Data Types (ADTs)
  * Good Class Interfaces - Good Abstraction, Good Encapsulation
  * Design and Implementation Issues
  * Reasons to Create a Class
  * Language-Specific Issues
  * Beyond Classes: Packages

* High-Quality Routines
  * Valid Reasons to Create a Routine
  * Design at the Routine Level
  * Good Routine Names
  * How Long Can a Routine Be?
  * How to Use Routine Parameters
  * Special Considerations in the Use of Functions
  * Macro Routines and Inline Routines

* Defensive Programming
  * Protecting Your Program from Invalid Inputs
  * Assertions
  * Error-Handling Techniques
  * Exceptions
  * Barricade Your Program to Contain the Damage Caused by Errors
  * Debugging Aids
  * Determining How Much Defensive Programming to Leave in Production Code
  * Being Defensive About Defensive Programming

* The Pseudocode Programming Process
  * Summary of Steps in Building Classes and Routines
  * Pseudocode for Pros
  * Constructing Routines by Using the PPP
  * Alternatives to the PPP

* Variables
* General Issues in Using Variables
  * Data Literacy
  * Making Variable Declarations Easy
  * Guidelines for Initializing Variables
  * Scope
  * Persistence
  * Binding Time
  * Relationship Between Data Types and Control Structures
  * Using Each Variable for Exactly One Purpose

* The Power of Variable Names
  * Considerations in Choosing Good Names
  * Naming Specific Types of Data
  * The Power of Naming Conventions
  * Informal Naming Conventions
  * Standardized Prefixes
  * Creating Short Names That Are Readable
  * Kinds of Names to Avoid

* Fundamental Data Types
  * Numbers in General
  * Integers
  * Floating-Point Numbers
  * Characters and Strings
  * Boolean Variables
  * Enumerated Types
  * Named Constants
  * rrays
  * Creating Your Own Types (Type Aliasing)

* Unusual Data Types
  * Structures
  * Pointers
  * Global Data

* Organizing Straight-Line Code
  * Statements That Must Be in a Specific Order
  * Statements Whose Order Doesn't Matter

* Using Conditionals
  * if Statements
  * case Statements

* Controlling Loops
  * Selecting the Kind of Loop
  * Controlling the Loop
  * Creating Loops Easily—From the Inside Out
  * Correspondence Between Loops and Arrays

* Unusual Control Structures
  * Multiple Returns from a Routine
  * Recursion
  * goto
  * Perspective on Unusual Control Structures

* Table-Driven Methods
  * General Considerations in Using Table-Driven Methods
  * Direct Access Tables
  * Indexed Access Tables
  * Stair-Step Access Tables
  * Other Examples of Table Lookups

* General Control Issues
  * Boolean Expressions
  * Compound Statements (Blocks)
  * Null Statements
  * Taming Dangerously Deep Nesting
  * A Programming Foundation: Structured Programming
  * Control Structures and Complexity

* The Software-Quality Landscape
  * Characteristics of Software Quality
  * Techniques for Improving Software Quality
  * Relative Effectiveness of Quality Techniques
  * When to Do Quality Assurance
  * The General Principle of Software Quality

* Collaborative Construction
  * Overview of Collaborative Development Practices
  * Pair Programming
  * Formal Inspections
  * Other Kinds of Collaborative Development Practices

* Developer Testing
  * Role of Developer Testing in Software Quality
  * Recommended Approach to Developer Testing
  * Bag of Testing Tricks
  * Typical Errors
  * Test-Support Tools
  * Improving Your Testing
  * Keeping Test Records

* Debugging
  * Overview of Debugging Issues
  * Finding a Defect
  * Fixing a Defect
  * Psychological Considerations in Debugging
  * Debugging Tools—Obvious and Not-So-Obvious

* Refactoring
  * Kinds of Software Evolution
  * Introduction to Refactoring
  * Specific Refactorings
  * Refactoring Safely
  * Refactoring Strategies

* Code-Tuning Strategies
  * Performance Overview
  * Introduction to Code Tuning
  * Kinds of Fat and Molasses
  * Measurement
  * Iteration
  * Summary of the Approach to Code Tuning

* Code-Tuning Techniques
  * Logic
  * Loops
  * Data Transformations
  * Expressions
  * Routines
  * Recoding in a Low-Level Language
  * The More Things Change, the More They Stay the Same

* How Program Size Affects Construction
  * Communication and Size
  * Range of Project Sizes
  * Effect of Project Size on Errors
  * Effect of Project Size on Productivity
  * Effect of Project Size on Development Activities

* Managing Construction
  * Encouraging Good Coding
  * Configuration Management
  * Estimating a Construction Schedule
  * Measurement
  * Treating Programmers as People
  * Managing Your Manager

* Integration
  * Importance of the Integration Approach
  * Integration Frequency—Phased or Incremental?
  * Incremental Integration Strategies
  * Daily Build and Smoke Test

* Programming Tools
  * Design Tools
  * Source-Code Tools
  * Executable-Code Tools
  * Tool-Oriented Environments
  * Building Your Own Programming Tools
  * Tool Fantasyland

* Layout and Style
  * Layout Fundamentals
  * Layout Techniques
  * Layout Styles
  * Laying Out Control Structures
  * Laying Out Individual Statements
  * Laying Out Comments
  * Laying Out Routines
  * Laying Out Classes

* Self-Documenting Code
  * External Documentation
  * Programming Style as Documentation
  * To Comment or Not to Comment
  * Keys to Effective Comments
  * Commenting Techniques
  * IEEE Standards

* Personal Character
  * Isn't Personal Character Off the Topic?
  * Intelligence and Humility
  * Curiosity
  * Intellectual Honesty
  * Communication and Cooperation
  * Creativity and Discipline
  * Laziness
  * Characteristics That Don't Matter As Much As You Might Think
  * Habits

* Themes in Software Craftsmanship
  * Conquer Complexity
  * Pick Your Process
  * Write Programs for People First, Computers Second
  * Program into Your Language, Not in It
  * Focus Your Attention with the Help of Conventions
  * Program in Terms of the Problem Domain
  * Watch for Falling Rocks
  * Iterate, Repeatedly, Again and Again
  * Thou Shalt Rend Software and Religion Asunder

## 轉錄 電子學 林昀老師

由於電子學內容過於龐大，並且教授的學術有所專攻，因此，一份的考卷必是有所偏重，難能全面性地測驗整個電子學。
再者，各研究所的發展重點並非相同，研究主題更是隨教授之專長而異‧

因此，電子學考題之趨勢必然是：
(1)主題有所偏重或集中，鮮有均勻分佈，對於該所不重要的課題將不會成為考題重點。因此，考生應打聽該研究所的考試主要範圍，方有效率。
(2)教授時間有限，故自我思考設計的題目較少，大多是將基本電路加以變化，或是採用迂迴問法，因此，教科書的例題或習題常是考題來源，考生應清楚該研究所所列出的教科書，並演練與熟悉之。
(3)考試時間有限，故分析過於複雜與難算的題目，並不是適合於考試。因此，考生在準備期間，若時間不暇，則應暫拋計算甚久之題目。
(4)若出題教授未更動，則其出題風格並不會有太強的變化，因此，由歷屆考古題之中可助於主題與出題方式之瞭解。
(5)著名國立大學的研究所考題常有綜合題，或是較為深入的考法，藉此考驗學生的電路理解程度與實力，因此，有志考生對於電路之設計理念應要深耕，方能競爭。
(6)前一、二年的考古題常出現選擇題，今年則是較少，簡答題的數量反而增加，考生平時應試著訓練理念之表達與描述。若畫圖輔助時，則應注意座標軸的標示，尤其是CMOS剖面圖，則應設法以斜線畫法來清晰表達各區，並多加練習。

在此老師建議同學電子學準備要領有五大步驟，如下：

* 第一階段：上課的所有章節唸完一遍
  * (a)儘速吸收半導體材料觀念，與電晶體導通受控的物理現象，以及其相關的數學語言描述，以建立應用概念
  * (b)注意各種特性圖所論的意義或表達
  * (c)先掌握基本電路的結構用意與其缺點
  * (d)推廣至改良電路，瞭解其設計觀念與分析觀點，明白其重點或優點
  * (e)演算各章節的例題，計算或分析時，因解法常有數種，因此，切勿背誦任何老師的解法，甚至應要懷疑解答有誤或不良。其次，對於解法，自己必須設法思維與提出，並比對於老師解法，對於較優之解法，應設法詮釋其理念或關鍵，並做簡易筆記。

* 第二階段：專攻主題範圍
  * (a)對於想就讀的所系，打聽與確認該所三年內電子學的主要範圍或主題（可參考以下的96年配分表），不過，出題的教授時有更換，主題或考題風格常有變化。
  * (b)針對所專攻的主題，演練於教科書（Smith或Neamen）課本上的例題與練習題，可藉此熟悉一般通用的解法，並適應其英文語句。
  * (c)比較上課老師與教科書之解法是否有所差異，並做評論。
  * (d)演練該單元主題的後方的習題，但注意市售的習題解答常有錯誤，應小心為宜，有些解法常直接代入公式，未見分析理念，這會讓學生以為要背誦公式，其實，公式應盡量理解，達到不背卻可熟練的自然地步。不過，有些半導體材料或pn接面的公式過於複雜，則必須強記與熟練。

* 第三階段：歷屆試題演練
  * (a)先針對想就讀的所系之近二年歷屆考古題來進行演練，由於錯誤在所難免，故應質疑其答案是否正確，解法是否良好，是否有更佳之解法。另外，一般解答過程頗為簡潔，應自行補充解法的分析理念或流程。
  * (b)擴大演練於相近系所的歷屆考古題
  * (c)專攻的主題範圍將會隨之擴大，應先複習上課講義資料的觀念說明、例題，以及教科書的例題與練習題。
  * (d)複習所專攻的歷屆考古題，並應加以限時100分鐘與限定計算機，以模擬考試情形。

* 第四階段：演練教科書上的所有例題
  * (a)對於需要強記的公式，應做筆記整理。
  * (b)將教科書的所有例題與練習題加以演算，以彌補其他的主題。

* 第五階段：
  * (a)調適作息，讓早上能維持最佳精神，應考時心情放輕鬆，不要空腹或過飽。
  * (b)遇到艱深難題，不必氣餒，大眾皆敗；題目簡易，毋需高興，人人皆可破解。
  * (c)若報考多校，則每考完一校，心情保持穩定與愉快，切勿過於煩躁或憂慮，應按部就班地複習，但毋需熬夜。